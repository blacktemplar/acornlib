from util import constant, compose
from nat import Nat
from rat import Rat
from list import partial, sum, map, List
from list.list_functional import reverse, sum_reverse, reverse_get_idx
from list.list_sum import map_range, list_extensionality, sum_scalar_mul, map_sum_add, scalar_mul
from option import Option
from real.real_ring import Real, converges, converges_to, limit, lift_seq
from real.real_series import seq_lte, is_lower_bound, add_seq, mul_seq
from real.real_base import lte_add_left
from semigroup import mul_fn
from add_semigroup import add_fn
from add_comm_monoid import AddCommMonoid

numerals Real

// This file defines the Cauchy product of two series and proves theorems about it.

attributes Real {
    // Placeholder to let other modules import Real from here.
}

/// The coefficient function for the Cauchy product at index n.
/// For a fixed n, this returns a function mapping k to a(k) * b(n-k).
define cauchy_coefficient(a: Nat -> Real, b: Nat -> Real, n: Nat) -> (Nat -> Real) {
    function(k: Nat) { a(k) * b(n - k) }
}

/// The Cauchy product of two sequences at index n.
/// This computes ∑_{k=0}^{n} a(k) * b(n-k).
define cauchy_product(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// The sequence of Cauchy products.
define cauchy_seq(a: Nat -> Real, b: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { cauchy_product(a, b, n) }
}

theorem cauchy_product_zero(a: Nat -> Real, b: Nat -> Real) {
    cauchy_product(a, b, Nat.0) = a(Nat.0) * b(Nat.0)
} by {
    Nat.0.suc = Nat.1
    Nat.1.range = List.singleton(Nat.0)
    let mapped = map(Nat.1.range, function(k: Nat) { a(k) * b(Nat.0 - k) })
    Nat.0 - Nat.0 = Nat.0
    mapped = List.singleton(a(Nat.0) * b(Nat.0))
    sum(mapped) = a(Nat.0) * b(Nat.0)
}

/// If we map a list with a function that always returns zero, the sum is zero.
theorem sum_map_zero[T](items: List[T], f: T -> Real) {
    (forall(x: T) { f(x) = Real.0 })
    implies
    sum(map(items, f)) = Real.0
} by {
    define p(xs: List[T]) -> Bool {
        (forall(x: T) { f(x) = Real.0 })
        implies
        sum(map(xs, f)) = Real.0
    }

    // Base case: empty list
    map(List.nil[T], f) = List.nil[Real]
    sum(List.nil[Real]) = Real.0
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if forall(x: T) { f(x) = Real.0 } {
                // Apply the hypothesis to tail
                sum(map(tail, f)) = Real.0

                // Now work on the cons case
                map(List.cons(head, tail), f) = List.cons(f(head), map(tail, f))
                sum(List.cons(f(head), map(tail, f))) = f(head) + sum(map(tail, f))
                f(head) = Real.0
                sum(List.cons(f(head), map(tail, f))) = Real.0 + Real.0
                sum(List.cons(f(head), map(tail, f))) = Real.0
                sum(map(List.cons(head, tail), f)) = Real.0
            }
            p(List.cons(head, tail))
        }
    }
}

/// If a is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_left(b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n)(k) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    a(k) = Real.0
    Real.0 * b(n - k) = Real.0
}

/// If a is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_left_fn(b: Nat -> Real, n: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n) = constant[Nat, Real](Real.0)
} by {
    let a = constant[Nat, Real](Real.0)
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
}

/// If b is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_right(a: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n)(k) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    b(n - k) = Real.0
    a(k) * Real.0 = Real.0
}

/// If b is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_right_fn(a: Nat -> Real, n: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n) = constant[Nat, Real](Real.0)
} by {
    let b = constant[Nat, Real](Real.0)
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
}

/// Helper lemma: reverse of mapped range with cauchy_coefficient equals mapped range with swapped coefficients.
theorem cauchy_reverse_map_eq(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) =
    map(n.suc.range, cauchy_coefficient(b, a, n))
} by {
    let left_list = reverse(map(n.suc.range, cauchy_coefficient(a, b, n)))
    let right_list = map(n.suc.range, cauchy_coefficient(b, a, n))

    // Both lists have the same length
    left_list.length = map(n.suc.range, cauchy_coefficient(a, b, n)).length
    map(n.suc.range, cauchy_coefficient(a, b, n)).length = n.suc.range.length
    n.suc.range.length = n.suc
    right_list.length = map(n.suc.range, cauchy_coefficient(b, a, n)).length
    map(n.suc.range, cauchy_coefficient(b, a, n)).length = n.suc.range.length
    left_list.length = right_list.length

    // Show they agree at every index
    forall(idx: Nat) {
        if idx < left_list.length {
            // idx < n.suc
            idx < n.suc

            // Element of left_list at idx using reverse_get_idx
            let mapped = map(n.suc.range, cauchy_coefficient(a, b, n))
            reverse_get_idx(mapped, idx)
            mapped.length = n.suc
            left_list.get_idx(idx) = mapped.get_idx(mapped.length - Nat.1 - idx)

            // mapped.length - 1 - idx = n - idx
            mapped.length - Nat.1 - idx = n - idx

            // Show n - idx < n.suc
            n - idx <= n
            n < n.suc
            n - idx < n.suc

            // Apply map_range with cauchy_coefficient
            map_range(n.suc, n - idx, cauchy_coefficient(a, b, n))
            mapped.get_idx(n - idx) = Option.some(cauchy_coefficient(a, b, n)(n - idx))

            // Expand cauchy_coefficient
            cauchy_coefficient(a, b, n)(n - idx) = a(n - idx) * b(n - (n - idx))
            n - (n - idx) = idx
            cauchy_coefficient(a, b, n)(n - idx) = a(n - idx) * b(idx)

            left_list.get_idx(idx) = Option.some(a(n - idx) * b(idx))

            // By commutativity
            a(n - idx) * b(idx) = b(idx) * a(n - idx)

            // Element of right_list at idx
            map_range(n.suc, idx, cauchy_coefficient(b, a, n))
            right_list.get_idx(idx) = Option.some(cauchy_coefficient(b, a, n)(idx))

            // Expand cauchy_coefficient
            cauchy_coefficient(b, a, n)(idx) = b(idx) * a(n - idx)

            // Therefore they're equal
            left_list.get_idx(idx) = Option.some(b(idx) * a(n - idx))
            left_list.get_idx(idx) = right_list.get_idx(idx)
        }
    }

    // Apply list extensionality
    list_extensionality(left_list, right_list)
    left_list = right_list
}

/// Cauchy product is commutative.
theorem cauchy_product_comm(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, b, n) = cauchy_product(b, a, n)
} by {
    // Expand definitions
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(b, a, n) = sum(map(n.suc.range, cauchy_coefficient(b, a, n)))

    // Use sum_reverse
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = sum(reverse(map(n.suc.range, cauchy_coefficient(a, b, n))))

    // Use helper lemma
    cauchy_reverse_map_eq(a, b, n)
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) = map(n.suc.range, cauchy_coefficient(b, a, n))

    // Combine
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = sum(map(n.suc.range, cauchy_coefficient(b, a, n)))
}

/// Cauchy product with a zero sequence on the left.
theorem cauchy_product_zero_left(b: Nat -> Real, n: Nat) {
    cauchy_product(constant[Nat, Real](Real.0), b, n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function
    cauchy_coefficient(a, b, n) = constant[Nat, Real](Real.0)

    // Therefore every application returns zero
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
    }

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, b, n) = Real.0
}

/// Cauchy product with a zero sequence on the right.
theorem cauchy_product_zero_right(a: Nat -> Real, n: Nat) {
    cauchy_product(a, constant[Nat, Real](Real.0), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function
    cauchy_coefficient(a, b, n) = constant[Nat, Real](Real.0)

    // Therefore every application returns zero
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
    }

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, b, n) = Real.0
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the first argument.
theorem cauchy_coefficient_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
} by {
    // Expand cauchy_coefficient definition
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = mul_fn(c, a)(k) * b(n - k)
    mul_fn(c, a)(k) = c * a(k)
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = (c * a(k)) * b(n - k)

    // Use associativity
    (c * a(k)) * b(n - k) = c * (a(k) * b(n - k))

    // Recognize the right side as the original coefficient
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    c * (a(k) * b(n - k)) = c * cauchy_coefficient(a, b, n)(k)
}

/// Linearity in the first argument: scalar multiplication factors out.
theorem cauchy_product_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(mul_fn(c, a), b, n) = c * cauchy_product(a, b, n)
} by {
    // Expand cauchy_product definitions
    cauchy_product(mul_fn(c, a), b, n) = sum(map(n.suc.range, cauchy_coefficient(mul_fn(c, a), b, n)))
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))

    // Show that the coefficient functions are related by scalar multiplication
    forall(k: Nat) {
        cauchy_coefficient(mul_fn(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
        scalar_mul(c)(cauchy_coefficient(a, b, n)(k)) = c * cauchy_coefficient(a, b, n)(k)
    }

    // The two functions are equal
    cauchy_coefficient(mul_fn(c, a), b, n) = compose(scalar_mul(c), cauchy_coefficient(a, b, n))

    // Use sum_scalar_mul to factor out the constant
    sum(map(n.suc.range, cauchy_coefficient(mul_fn(c, a), b, n))) = sum(map(n.suc.range, compose(scalar_mul(c), cauchy_coefficient(a, b, n))))
    sum(map(n.suc.range, compose(scalar_mul(c), cauchy_coefficient(a, b, n)))) = sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c)))
    sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the second argument.
theorem cauchy_coefficient_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
} by {
    // Expand cauchy_coefficient definition
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = a(k) * mul_fn(c, b)(n - k)
    mul_fn(c, b)(n - k) = c * b(n - k)
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = a(k) * (c * b(n - k))

    // Use associativity and commutativity
    a(k) * (c * b(n - k)) = a(k) * (b(n - k) * c)
    a(k) * (b(n - k) * c) = (a(k) * b(n - k)) * c
    (a(k) * b(n - k)) * c = c * (a(k) * b(n - k))

    // Recognize the right side as the original coefficient
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    c * (a(k) * b(n - k)) = c * cauchy_coefficient(a, b, n)(k)
}

/// Linearity in the second argument: scalar multiplication factors out.
theorem cauchy_product_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, mul_fn(c, b), n) = c * cauchy_product(a, b, n)
} by {
    // Expand cauchy_product definitions
    cauchy_product(a, mul_fn(c, b), n) = sum(map(n.suc.range, cauchy_coefficient(a, mul_fn(c, b), n)))
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))

    // Show that the coefficient functions are related by scalar multiplication
    forall(k: Nat) {
        cauchy_coefficient(a, mul_fn(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
        scalar_mul(c)(cauchy_coefficient(a, b, n)(k)) = c * cauchy_coefficient(a, b, n)(k)
    }

    // The two functions are equal
    cauchy_coefficient(a, mul_fn(c, b), n) = compose(scalar_mul(c), cauchy_coefficient(a, b, n))

    // Use sum_scalar_mul to factor out the constant
    sum(map(n.suc.range, cauchy_coefficient(a, mul_fn(c, b), n))) = sum(map(n.suc.range, compose(scalar_mul(c), cauchy_coefficient(a, b, n))))
    sum(map(n.suc.range, compose(scalar_mul(c), cauchy_coefficient(a, b, n)))) = sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c)))
    sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes addition in the first argument.
theorem cauchy_coefficient_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
} by {
    // Expand cauchy_coefficient definition
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = add_fn(a, aa)(k) * b(n - k)
    add_fn(a, aa)(k) = a(k) + aa(k)
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = (a(k) + aa(k)) * b(n - k)

    // Use distributivity
    (a(k) + aa(k)) * b(n - k) = a(k) * b(n - k) + aa(k) * b(n - k)

    // Recognize the right side as the sum of coefficients
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    cauchy_coefficient(aa, b, n)(k) = aa(k) * b(n - k)
    a(k) * b(n - k) + aa(k) * b(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
}

/// Distributivity in the first argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(add_fn(a, aa), b, n) = cauchy_product(a, b, n) + cauchy_product(aa, b, n)
} by {
    // Expand cauchy_product definitions
    cauchy_product(add_fn(a, aa), b, n) = sum(map(n.suc.range, cauchy_coefficient(add_fn(a, aa), b, n)))
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(aa, b, n) = sum(map(n.suc.range, cauchy_coefficient(aa, b, n)))

    // Show that the coefficient functions are related by addition
    forall(k: Nat) {
        cauchy_coefficient(add_fn(a, aa), b, n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
        add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
    }

    // The two functions are equal
    cauchy_coefficient(add_fn(a, aa), b, n) = add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))

    // Use map_sum_add to split the sum
    sum(map(n.suc.range, cauchy_coefficient(add_fn(a, aa), b, n))) = sum(map(n.suc.range, add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))))
    sum(map(n.suc.range, add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n)))) = sum(map(n.suc.range, cauchy_coefficient(a, b, n))) + sum(map(n.suc.range, cauchy_coefficient(aa, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes addition in the second argument.
theorem cauchy_coefficient_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
} by {
    // Expand cauchy_coefficient definition
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = a(k) * add_fn(b, bb)(n - k)
    add_fn(b, bb)(n - k) = b(n - k) + bb(n - k)
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = a(k) * (b(n - k) + bb(n - k))

    // Use distributivity
    a(k) * (b(n - k) + bb(n - k)) = a(k) * b(n - k) + a(k) * bb(n - k)

    // Recognize the right side as the sum of coefficients
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    cauchy_coefficient(a, bb, n)(k) = a(k) * bb(n - k)
    a(k) * b(n - k) + a(k) * bb(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
}

/// Distributivity in the second argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    cauchy_product(a, add_fn(b, bb), n) = cauchy_product(a, b, n) + cauchy_product(a, bb, n)
} by {
    // Expand cauchy_product definitions
    cauchy_product(a, add_fn(b, bb), n) = sum(map(n.suc.range, cauchy_coefficient(a, add_fn(b, bb), n)))
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, bb, n) = sum(map(n.suc.range, cauchy_coefficient(a, bb, n)))

    // Show that the coefficient functions are related by addition
    forall(k: Nat) {
        cauchy_coefficient(a, add_fn(b, bb), n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
        add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(a, bb, n))(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
    }

    // The two functions are equal
    cauchy_coefficient(a, add_fn(b, bb), n) = add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(a, bb, n))

    // Use map_sum_add to split the sum
    sum(map(n.suc.range, cauchy_coefficient(a, add_fn(b, bb), n))) = sum(map(n.suc.range, add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(a, bb, n))))
    sum(map(n.suc.range, add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(a, bb, n)))) = sum(map(n.suc.range, cauchy_coefficient(a, b, n))) + sum(map(n.suc.range, cauchy_coefficient(a, bb, n)))
}

/// Partial sum of Cauchy product with zero sequence on the left is zero.
theorem partial_cauchy_zero_left(b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(constant[Nat, Real](Real.0), b), n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
    let c = cauchy_seq(a, b)

    // Show that cauchy_seq(a, b) is the constant zero function
    forall(k: Nat) {
        c(k) = cauchy_product(a, b, k)
        cauchy_product(a, b, k) = Real.0
        c(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
    c = constant[Nat, Real](Real.0)

    // Partial sum of constant zero is zero
    partial(c, n) = sum(map(n.range, c))
    partial(c, n) = sum(map(n.range, constant[Nat, Real](Real.0)))

    forall(k: Nat) {
        constant[Nat, Real](Real.0)(k) = Real.0
    }

    sum(map(n.range, constant[Nat, Real](Real.0))) = Real.0
    partial(c, n) = Real.0
}

/// Partial sum of Cauchy product with zero sequence on the right is zero.
theorem partial_cauchy_zero_right(a: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, constant[Nat, Real](Real.0)), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
    let c = cauchy_seq(a, b)

    // Show that cauchy_seq(a, b) is the constant zero function
    forall(k: Nat) {
        c(k) = cauchy_product(a, b, k)
        cauchy_product(a, b, k) = Real.0
        c(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
    c = constant[Nat, Real](Real.0)

    // Partial sum of constant zero is zero
    partial(c, n) = sum(map(n.range, c))
    partial(c, n) = sum(map(n.range, constant[Nat, Real](Real.0)))

    forall(k: Nat) {
        constant[Nat, Real](Real.0)(k) = Real.0
    }

    sum(map(n.range, constant[Nat, Real](Real.0))) = Real.0
    partial(c, n) = Real.0
}

/// Partial sum distributes over addition in the first argument.
theorem partial_cauchy_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(add_fn(a, aa), b), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(aa, b), n)
} by {
    // Show that cauchy_seq distributes over addition
    forall(k: Nat) {
        cauchy_seq(add_fn(a, aa), b)(k) = cauchy_product(add_fn(a, aa), b, k)
        cauchy_product(add_fn(a, aa), b, k) = cauchy_product(a, b, k) + cauchy_product(aa, b, k)
        cauchy_seq(a, b)(k) = cauchy_product(a, b, k)
        cauchy_seq(aa, b)(k) = cauchy_product(aa, b, k)
        cauchy_seq(add_fn(a, aa), b)(k) = cauchy_seq(a, b)(k) + cauchy_seq(aa, b)(k)
        add_fn(cauchy_seq(a, b), cauchy_seq(aa, b))(k) = cauchy_seq(a, b)(k) + cauchy_seq(aa, b)(k)
    }

    // Therefore the sequences are equal
    cauchy_seq(add_fn(a, aa), b) = add_fn(cauchy_seq(a, b), cauchy_seq(aa, b))

    // Use partial_add to distribute the partial sum
    partial(cauchy_seq(add_fn(a, aa), b), n) = partial(add_fn(cauchy_seq(a, b), cauchy_seq(aa, b)), n)
    partial(add_fn(cauchy_seq(a, b), cauchy_seq(aa, b)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(aa, b), n)
}

/// Partial sum distributes over addition in the second argument.
theorem partial_cauchy_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, add_fn(b, bb)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(a, bb), n)
} by {
    // Show that cauchy_seq distributes over addition
    forall(k: Nat) {
        cauchy_seq(a, add_fn(b, bb))(k) = cauchy_product(a, add_fn(b, bb), k)
        cauchy_product(a, add_fn(b, bb), k) = cauchy_product(a, b, k) + cauchy_product(a, bb, k)
        cauchy_seq(a, b)(k) = cauchy_product(a, b, k)
        cauchy_seq(a, bb)(k) = cauchy_product(a, bb, k)
        cauchy_seq(a, add_fn(b, bb))(k) = cauchy_seq(a, b)(k) + cauchy_seq(a, bb)(k)
        add_fn(cauchy_seq(a, b), cauchy_seq(a, bb))(k) = cauchy_seq(a, b)(k) + cauchy_seq(a, bb)(k)
    }

    // Therefore the sequences are equal
    cauchy_seq(a, add_fn(b, bb)) = add_fn(cauchy_seq(a, b), cauchy_seq(a, bb))

    // Use partial_add to distribute the partial sum
    partial(cauchy_seq(a, add_fn(b, bb)), n) = partial(add_fn(cauchy_seq(a, b), cauchy_seq(a, bb)), n)
    partial(add_fn(cauchy_seq(a, b), cauchy_seq(a, bb)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(a, bb), n)
}

/// Scalar multiplication factors out of partial sum in the first argument.
theorem partial_cauchy_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(mul_fn(c, a), b), n) = c * partial(cauchy_seq(a, b), n)
} by {
    // Show that cauchy_seq factors out scalar multiplication
    forall(k: Nat) {
        cauchy_seq(mul_fn(c, a), b)(k) = cauchy_product(mul_fn(c, a), b, k)
        cauchy_product(mul_fn(c, a), b, k) = c * cauchy_product(a, b, k)
        cauchy_seq(a, b)(k) = cauchy_product(a, b, k)
        cauchy_seq(mul_fn(c, a), b)(k) = c * cauchy_seq(a, b)(k)
        mul_fn(c, cauchy_seq(a, b))(k) = c * cauchy_seq(a, b)(k)
    }

    // Therefore the sequences are equal
    cauchy_seq(mul_fn(c, a), b) = mul_fn(c, cauchy_seq(a, b))

    // Use partial_scalar_mul to factor out the constant
    partial(cauchy_seq(mul_fn(c, a), b), n) = partial(mul_fn(c, cauchy_seq(a, b)), n)
    partial(mul_fn(c, cauchy_seq(a, b)), n) = c * partial(cauchy_seq(a, b), n)
}

/// Scalar multiplication factors out of partial sum in the second argument.
theorem partial_cauchy_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, mul_fn(c, b)), n) = c * partial(cauchy_seq(a, b), n)
} by {
    // Show that cauchy_seq factors out scalar multiplication
    forall(k: Nat) {
        cauchy_seq(a, mul_fn(c, b))(k) = cauchy_product(a, mul_fn(c, b), k)
        cauchy_product(a, mul_fn(c, b), k) = c * cauchy_product(a, b, k)
        cauchy_seq(a, b)(k) = cauchy_product(a, b, k)
        cauchy_seq(a, mul_fn(c, b))(k) = c * cauchy_seq(a, b)(k)
        mul_fn(c, cauchy_seq(a, b))(k) = c * cauchy_seq(a, b)(k)
    }

    // Therefore the sequences are equal
    cauchy_seq(a, mul_fn(c, b)) = mul_fn(c, cauchy_seq(a, b))

    // Use partial_scalar_mul to factor out the constant
    partial(cauchy_seq(a, mul_fn(c, b)), n) = partial(mul_fn(c, cauchy_seq(a, b)), n)
    partial(mul_fn(c, cauchy_seq(a, b)), n) = c * partial(cauchy_seq(a, b), n)
}

// ============================================================================
// Absolute Convergence Infrastructure
// ============================================================================

/// The absolute value of each element in a sequence.
/// For a sequence a, this returns the sequence n ↦ |a(n)|.
define abs_fn(a: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { a(n).abs }
}

/// A series converges absolutely if the series of absolute values converges.
define absolutely_converges(a: Nat -> Real) -> Bool {
    converges(partial(abs_fn(a)))
}

/// The absolute value of any element in the constant zero sequence is zero.
theorem abs_fn_zero(n: Nat) {
    abs_fn(constant[Nat, Real](Real.0))(n) = Real.0
} by {
    abs_fn(constant[Nat, Real](Real.0))(n) = constant[Nat, Real](Real.0)(n).abs
    constant[Nat, Real](Real.0)(n) = Real.0
    Real.0.abs = Real.0
}

/// The absolute value of any element in a sequence is nonnegative.
theorem abs_fn_nonneg(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) >= Real.0
} by {
    abs_fn(a)(n) = a(n).abs
    a(n).abs >= Real.0
}

/// Absolute value commutes with scalar multiplication (up to taking abs of scalar).
theorem abs_fn_scalar_mul(c: Real, a: Nat -> Real, n: Nat) {
    abs_fn(mul_fn(c, a))(n) = c.abs * abs_fn(a)(n)
} by {
    abs_fn(mul_fn(c, a))(n) = mul_fn(c, a)(n).abs
    mul_fn(c, a)(n) = c * a(n)
    (c * a(n)).abs = c.abs * a(n).abs
    abs_fn(a)(n) = a(n).abs
    c.abs * a(n).abs = c.abs * abs_fn(a)(n)
}

/// abs_fn is equivalent to composing with Real.abs.
theorem abs_fn_eq_compose(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) = compose(Real.abs, a)(n)
} by {
    abs_fn(a)(n) = a(n).abs
    compose(Real.abs, a)(n) = Real.abs(a(n))
    Real.abs(a(n)) = a(n).abs
}

/// Absolute convergence implies convergence (alternate formulation).
/// This connects our definition to the existing theorem in real_series.ac.
theorem absolutely_converges_imp_converges(a: Nat -> Real) {
    absolutely_converges(a) implies converges(partial(a))
} by {
    from real.real_series import abs_conv_imp_conv

    if absolutely_converges(a) {
        // By definition, absolutely_converges(a) means converges(partial(abs_fn(a)))
        converges(partial(abs_fn(a)))

        // Show that abs_fn(a) = compose(Real.abs, a)
        forall(n: Nat) {
            abs_fn(a)(n) = compose(Real.abs, a)(n)
        }
        abs_fn(a) = compose(Real.abs, a)

        // Therefore converges(partial(compose(Real.abs, a)))
        partial(abs_fn(a)) = partial(compose(Real.abs, a))
        converges(partial(compose(Real.abs, a)))

        // Apply abs_conv_imp_conv
        abs_conv_imp_conv(a)
        converges(partial(a))
    }
}

/// Absolute convergence is preserved under scalar multiplication.
theorem absolutely_converges_scalar_mul(c: Real, a: Nat -> Real) {
    absolutely_converges(a) implies absolutely_converges(mul_fn(c, a))
} by {
    from real.real_series import converges_mul_seq

    if absolutely_converges(a) {
        converges(partial(abs_fn(a)))

        // Show that abs_fn(mul_fn(c, a)) relates to abs_fn(a)
        forall(n: Nat) {
            abs_fn(mul_fn(c, a))(n) = c.abs * abs_fn(a)(n)
            mul_fn(c.abs, abs_fn(a))(n) = c.abs * abs_fn(a)(n)
        }
        abs_fn(mul_fn(c, a)) = mul_fn(c.abs, abs_fn(a))

        // Therefore partial(abs_fn(mul_fn(c, a))) = c.abs * partial(abs_fn(a))
        partial(abs_fn(mul_fn(c, a))) = partial(mul_fn(c.abs, abs_fn(a)))
        partial(mul_fn(c.abs, abs_fn(a))) = mul_fn(c.abs, partial(abs_fn(a)))

        // Show that mul_fn and mul_seq are equal for our purposes
        forall(n: Nat) {
            mul_fn(c.abs, partial(abs_fn(a)))(n) = c.abs * partial(abs_fn(a))(n)
            mul_seq(c.abs, partial(abs_fn(a)))(n) = c.abs * partial(abs_fn(a))(n)
        }
        mul_fn(c.abs, partial(abs_fn(a))) = mul_seq(c.abs, partial(abs_fn(a)))

        // If partial(abs_fn(a)) converges, so does c.abs * partial(abs_fn(a))
        converges_mul_seq(c.abs, partial(abs_fn(a)))
        converges(mul_seq(c.abs, partial(abs_fn(a))))
        converges(mul_fn(c.abs, partial(abs_fn(a))))
        converges(partial(abs_fn(mul_fn(c, a))))
        absolutely_converges(mul_fn(c, a))
    }
}

/// Absolute convergence is preserved under addition of sequences.
theorem absolutely_converges_add(a: Nat -> Real, b: Nat -> Real) {
    absolutely_converges(a) and absolutely_converges(b)
    implies
    absolutely_converges(add_fn(a, b))
} by {
    from real.real_series import add_seq_converges, comparison_test

    if absolutely_converges(a) and absolutely_converges(b) {
        converges(partial(abs_fn(a)))
        converges(partial(abs_fn(b)))

        // For all n: |a(n) + b(n)| <= |a(n)| + |b(n)| by triangle inequality
        forall(n: Nat) {
            (a(n) + b(n)).abs <= a(n).abs + b(n).abs
            add_fn(a, b)(n) = a(n) + b(n)
            abs_fn(add_fn(a, b))(n) = add_fn(a, b)(n).abs
            abs_fn(add_fn(a, b))(n) <= a(n).abs + b(n).abs
            abs_fn(add_fn(a, b))(n) <= abs_fn(a)(n) + abs_fn(b)(n)
            abs_fn(add_fn(a, b))(n) <= add_fn(abs_fn(a), abs_fn(b))(n)
        }

        // Therefore seq_lte holds
        seq_lte(abs_fn(add_fn(a, b)), add_fn(abs_fn(a), abs_fn(b)))

        // abs_fn always produces nonnegative values
        forall(n: Nat) {
            abs_fn(add_fn(a, b))(n) >= Real.0
        }
        is_lower_bound(abs_fn(add_fn(a, b)), Real.0)

        // add_fn distributes over partial
        partial(add_fn(abs_fn(a), abs_fn(b))) = add_fn(partial(abs_fn(a)), partial(abs_fn(b)))

        // Show that add_fn and add_seq are equal for our purposes
        forall(n: Nat) {
            add_fn(partial(abs_fn(a)), partial(abs_fn(b)))(n) = partial(abs_fn(a))(n) + partial(abs_fn(b))(n)
            add_seq(partial(abs_fn(a)), partial(abs_fn(b)))(n) = partial(abs_fn(a))(n) + partial(abs_fn(b))(n)
        }
        add_fn(partial(abs_fn(a)), partial(abs_fn(b))) = add_seq(partial(abs_fn(a)), partial(abs_fn(b)))

        // If both converge, their sum converges
        add_seq_converges(partial(abs_fn(a)), partial(abs_fn(b)))
        converges(add_seq(partial(abs_fn(a)), partial(abs_fn(b))))
        converges(add_fn(partial(abs_fn(a)), partial(abs_fn(b))))
        converges(partial(add_fn(abs_fn(a), abs_fn(b))))

        // Apply comparison test
        comparison_test(abs_fn(add_fn(a, b)), add_fn(abs_fn(a), abs_fn(b)))
        converges(partial(abs_fn(add_fn(a, b))))
        absolutely_converges(add_fn(a, b))
    }
}

/// Tail bound for absolutely convergent series.
/// If a series converges absolutely, then tail sums can be made arbitrarily small.
/// For any ε > 0, there exists N such that for all n, m ≥ N with n ≤ m,
/// the sum of |a(k)| from k=n to k=m-1 is less than ε.
theorem abs_conv_tail_bound(a: Nat -> Real, eps: Real) {
    absolutely_converges(a) and eps.is_positive
    implies
    exists(big_n: Nat) {
        forall(n: Nat, m: Nat) {
            big_n <= n and n <= m
            implies
            partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
        }
    }
} by {
    from real.real_seq import cauchy_bound
    from real.real_series import distant_increasing, nonneg_imp_partial_increasing, is_increasing

    if absolutely_converges(a) and eps.is_positive {
        // absolutely_converges(a) means converges(partial(abs_fn(a)))
        converges(partial(abs_fn(a)))

        // Use the Cauchy criterion to get an N
        let big_n: Nat satisfy {
            cauchy_bound(partial(abs_fn(a)), big_n, eps)
        }

        forall(n: Nat, m: Nat) {
            if big_n <= n and n <= m {
                // By Cauchy criterion, the partial sums are close
                cauchy_bound(partial(abs_fn(a)), big_n, eps)
                partial(abs_fn(a))(n).is_close(partial(abs_fn(a))(m), eps)

                // Since abs_fn is nonnegative, partial sums are increasing
                forall(k: Nat) {
                    abs_fn(a)(k) >= Real.0
                }
                is_lower_bound(abs_fn(a), Real.0)
                nonneg_imp_partial_increasing(abs_fn(a))
                is_increasing(partial(abs_fn(a)))

                // When n <= m, the partial sums satisfy this ordering
                distant_increasing(partial(abs_fn(a)), n, m)
                partial(abs_fn(a))(n) <= partial(abs_fn(a))(m)

                // is_close is symmetric, so we also have
                partial(abs_fn(a))(m).is_close(partial(abs_fn(a))(n), eps)

                // Rewrite using function application notation
                partial(abs_fn(a), n) = partial(abs_fn(a))(n)
                partial(abs_fn(a), m) = partial(abs_fn(a))(m)
                partial(abs_fn(a), m).is_close(partial(abs_fn(a), n), eps)

                // This means the absolute difference is less than eps
                (partial(abs_fn(a), m) - partial(abs_fn(a), n)).abs < eps

                // Since partial is increasing and n <= m, we know partial(abs_fn(a), n) <= partial(abs_fn(a), m)
                // Therefore the difference partial(abs_fn(a), m) - partial(abs_fn(a), n) is non-negative
                // When a difference is non-negative, x - y >= 0, then (x - y).abs = x - y
                // So (partial(abs_fn(a), m) - partial(abs_fn(a), n)).abs = partial(abs_fn(a), m) - partial(abs_fn(a), n)
                partial(abs_fn(a), n) <= partial(abs_fn(a), m)
                partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
            }
        }
    }
}

// ============================================================================
// Cauchy Product Convergence (Mertens' Theorem)
// ============================================================================

/// Triangle inequality for sums: the absolute value of a sum is at most the sum of absolute values.
theorem sum_triangle_ineq(items: List[Real]) {
    (sum(items)).abs <= sum(map(items, Real.abs))
} by {
    from real.real_series import triangle_ineq

    // Proof by induction on list structure
    define p(xs: List[Real]) -> Bool {
        (sum(xs)).abs <= sum(map(xs, Real.abs))
    }

    // Base case: empty list
    sum(List.nil[Real]) = Real.0
    Real.0.abs = Real.0
    map(List.nil[Real], Real.abs) = List.nil[Real]
    sum(List.nil[Real]) = Real.0
    p(List.nil[Real])

    // Inductive step
    forall(head: Real, tail: List[Real]) {
        if p(tail) {
            // Assume: (sum(tail)).abs <= sum(map(tail, Real.abs))
            (sum(tail)).abs <= sum(map(tail, Real.abs))

            // Show for cons(head, tail)
            sum(List.cons(head, tail)) = head + sum(tail)
            (head + sum(tail)).abs <= head.abs + (sum(tail)).abs

            // Use inductive hypothesis
            head.abs + (sum(tail)).abs <= head.abs + sum(map(tail, Real.abs))

            // Show that right side equals sum(map(cons(head, tail), Real.abs))
            map(List.cons(head, tail), Real.abs) = List.cons(head.abs, map(tail, Real.abs))
            sum(List.cons(head.abs, map(tail, Real.abs))) = head.abs + sum(map(tail, Real.abs))

            // Combine
            (sum(List.cons(head, tail))).abs <= sum(map(List.cons(head, tail), Real.abs))
            p(List.cons(head, tail))
        }
    }

    p(items)
}

/// Pointwise less-than-or-equal for functions from Nat to Real.
define lte_fn(f: Nat -> Real, g: Nat -> Real) -> Bool {
    forall(k: Nat) { f(k) <= g(k) }
}

/// Helper: sum(map(n.range, f)) <= sum(map(n.range, g)) when f <= g pointwise.
/// Uses existing partial_seq_lte infrastructure.
theorem sum_map_range_le(n: Nat, f: Nat -> Real, g: Nat -> Real) {
    lte_fn(f, g) implies sum(map(n.range, f)) <= sum(map(n.range, g))
} by {
    from real.real_series import partial_seq_lte

    if lte_fn(f, g) {
        // lte_fn(f, g) is the same as seq_lte(f, g)
        lte_fn(f, g)
        forall(k: Nat) { f(k) <= g(k) }
        seq_lte(f, g)

        // Apply partial_seq_lte
        partial_seq_lte(f, g)
        seq_lte(partial(f), partial(g))
        forall(k: Nat) { partial(f)(k) <= partial(g)(k) }

        // partial(f, n) = sum(map(n.range, f)) by definition
        partial(f, n) = sum(map(n.range, f))
        partial(g, n) = sum(map(n.range, g))

        // Therefore
        partial(f)(n) <= partial(g)(n)
        sum(map(n.range, f)) <= sum(map(n.range, g))
    }
}

/// The absolute value of a Cauchy product coefficient is bounded by the
/// corresponding coefficient of the Cauchy product of absolute values.
theorem cauchy_coefficient_abs_bound(a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    (cauchy_coefficient(a, b, n)(k)).abs <= cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k)
} by {
    // Expand definitions
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    (a(k) * b(n - k)).abs = a(k).abs * b(n - k).abs

    // Expand the right side
    cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k) = abs_fn(a)(k) * abs_fn(b)(n - k)
    abs_fn(a)(k) = a(k).abs
    abs_fn(b)(n - k) = b(n - k).abs
    cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k) = a(k).abs * b(n - k).abs
}

/// The absolute value of the Cauchy product is bounded by the Cauchy product of absolute values.
theorem cauchy_product_abs_bound(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    (cauchy_product(a, b, n)).abs <= cauchy_product(abs_fn(a), abs_fn(b), n)
} by {
    // Expand definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(abs_fn(a), abs_fn(b), n) = sum(map(n.suc.range, cauchy_coefficient(abs_fn(a), abs_fn(b), n)))

    // Apply triangle inequality: |sum(...)| <= sum(|...|)
    sum_triangle_ineq(map(n.suc.range, cauchy_coefficient(a, b, n)))
    (sum(map(n.suc.range, cauchy_coefficient(a, b, n)))).abs <= sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), Real.abs))

    // Use map composition
    from list.list_sum import map_map
    map_map(n.suc.range, cauchy_coefficient(a, b, n), Real.abs)
    map(map(n.suc.range, cauchy_coefficient(a, b, n)), Real.abs) = map(n.suc.range, compose(Real.abs, cauchy_coefficient(a, b, n)))

    // For each coefficient, the absolute value is bounded
    forall(k: Nat) {
        cauchy_coefficient_abs_bound(a, b, n, k)
        (cauchy_coefficient(a, b, n)(k)).abs <= cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k)
        compose(Real.abs, cauchy_coefficient(a, b, n))(k) = Real.abs(cauchy_coefficient(a, b, n)(k))
        compose(Real.abs, cauchy_coefficient(a, b, n))(k) = (cauchy_coefficient(a, b, n)(k)).abs
        compose(Real.abs, cauchy_coefficient(a, b, n))(k) <= cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k)
    }
    lte_fn(compose(Real.abs, cauchy_coefficient(a, b, n)), cauchy_coefficient(abs_fn(a), abs_fn(b), n))

    // Apply sum_map_range_le
    sum_map_range_le(n.suc, compose(Real.abs, cauchy_coefficient(a, b, n)), cauchy_coefficient(abs_fn(a), abs_fn(b), n))
    sum(map(n.suc.range, compose(Real.abs, cauchy_coefficient(a, b, n)))) <= sum(map(n.suc.range, cauchy_coefficient(abs_fn(a), abs_fn(b), n)))

    // Combine by transitivity
    (cauchy_product(a, b, n)).abs <= cauchy_product(abs_fn(a), abs_fn(b), n)
}

/// Partial sum at index 0 is 0.
theorem partial_zero[A: AddCommMonoid](f: Nat -> A) {
    partial(f, Nat.0) = A.0
} by {
    partial(f, Nat.0) = sum(map(Nat.0.range, f))
    Nat.0.range = List.nil[Nat]
    map(List.nil[Nat], f) = List.nil[A]
    sum(List.nil[A]) = A.0
}

/// Scalar multiplication on the right of a partial sum.
theorem partial_mul_scalar_right(a: Nat -> Real, b: Real, n: Nat) {
    partial(a, n) * b = sum(map(n.range, mul_fn(b, a)))
} by {
    from list.list_sum import partial_scalar_mul

    // Use commutativity to swap the order
    partial(a, n) * b = b * partial(a, n)

    // Apply the left scalar multiplication theorem
    partial_scalar_mul(b, a, n)
    b * partial(a, n) = partial(mul_fn(b, a), n)

    // Expand the definition of partial
    partial(mul_fn(b, a), n) = sum(map(n.range, mul_fn(b, a)))

    partial(a, n) * b = sum(map(n.range, mul_fn(b, a)))
}

/// Double sum: sum over pairs (i, j) where i ∈ [0, n) and j ∈ [0, m).
/// This computes ∑_{i=0}^{n-1} ∑_{j=0}^{m-1} f(i, j).
define double_sum(n: Nat, m: Nat, f: (Nat, Nat) -> Real) -> Real {
    sum(map(n.range, function(i: Nat) {
        sum(map(m.range, function(j: Nat) { f(i, j) }))
    }))
}

/// Helper: scalar multiplication distributes into a sum.
/// For a constant c: c * ∑ᵢ b(i) = ∑ᵢ (c * b(i))
theorem scalar_mul_sum(c: Real, b: Nat -> Real, n: Nat) {
    c * sum(map(n.range, b)) = sum(map(n.range, mul_fn(c, b)))
} by {
    // Use commutativity and existing infrastructure
    sum(map(n.range, b)) = partial(b, n)
    c * sum(map(n.range, b)) = c * partial(b, n)

    // Apply partial_mul_scalar_right
    partial_mul_scalar_right(b, c, n)
    partial(b, n) * c = sum(map(n.range, mul_fn(c, b)))
    c * partial(b, n) = partial(b, n) * c
    c * partial(b, n) = sum(map(n.range, mul_fn(c, b)))

    c * sum(map(n.range, b)) = sum(map(n.range, mul_fn(c, b)))
}

/// Product of two partial sums equals a double sum over the product.
/// This is the key lemma for expanding (∑aᵢ)(∑bⱼ) into ∑ᵢ∑ⱼ aᵢbⱼ.
///
/// BUG: Acorn gives "variable 4 out of range in extended term" when expanding double_sum.
/// The problematic line is simply expanding the definition:
///   double_sum(n, n, function(i: Nat, j: Nat) { a(i) * b(j) }) = [RHS from definition]
/// This appears to be a bug in Acorn's handling of nested lambda substitution during
/// definition expansion with captured variables.
// theorem partial_product_as_double_sum(a: Nat -> Real, b: Nat -> Real, n: Nat) {
//     partial(a, n) * partial(b, n) = double_sum(n, n, function(i: Nat, j: Nat) { a(i) * b(j) })
// } by {
//     // Strategy: expand double_sum, use scalar_mul_sum twice to collapse nested sums
//     // Blocked by Acorn bug in definition expansion
// }

/// Helper: Cauchy product partial sums of nonnegative sequences are bounded by product of partial sums.
/// This is the key lemma for proving convergence of Cauchy products.
/// For nonnegative sequences a and b:
/// ∑_{k=0}^{n-1} (∑_{i=0}^{k} a_i * b_{k-i}) ≤ (∑_{i=0}^{n-1} a_i) * (∑_{j=0}^{n-1} b_j)
///
/// Note: This theorem is in progress. The mathematical argument is sound (the Cauchy product
/// includes only terms where i+j < n, while the expanded product includes all terms where
/// i < n and j < n, which is a superset). The challenge is handling the double sum manipulation
/// in Acorn's proof system. This may require additional lemmas about sums of products.
// theorem cauchy_partial_product_bound(a: Nat -> Real, b: Nat -> Real, n: Nat) {
//     is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
//     implies
//     partial(cauchy_seq(a, b), n) <= partial(a, n) * partial(b, n)
// } by {
//     from list.list_sum import partial_scalar_mul
//
//     define p(m: Nat) -> Bool {
//         is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
//         implies
//         partial(cauchy_seq(a, b), m) <= partial(a, m) * partial(b, m)
//     }
//
//     // Base case: n = 0
//     if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
//         partial_zero(cauchy_seq(a, b))
//         partial(cauchy_seq(a, b), Nat.0) = Real.0
//         partial_zero(a)
//         partial_zero(b)
//         partial(a, Nat.0) = Real.0
//         partial(b, Nat.0) = Real.0
//         partial(a, Nat.0) * partial(b, Nat.0) = Real.0 * Real.0
//         Real.0 * Real.0 = Real.0
//         partial(cauchy_seq(a, b), Nat.0) <= partial(a, Nat.0) * partial(b, Nat.0)
//     }
//     p(Nat.0)
//
//     // Inductive step
//     forall(m: Nat) {
//         if p(m) {
//             if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
//                 // Induction hypothesis
//                 p(m)
//                 partial(cauchy_seq(a, b), m) <= partial(a, m) * partial(b, m)
//
//                 // Expand partial(cauchy_seq(a, b), m.suc)
//                 m.suc.range = m.range + List.singleton(m)
//                 map(m.suc.range, cauchy_seq(a, b)) = map(m.range + List.singleton(m), cauchy_seq(a, b))
//                 from list.list_sum import map_add
//                 map_add(m.range, List.singleton(m), cauchy_seq(a, b))
//                 map(m.range + List.singleton(m), cauchy_seq(a, b)) = map(m.range, cauchy_seq(a, b)) + map(List.singleton(m), cauchy_seq(a, b))
//                 map(List.singleton(m), cauchy_seq(a, b)) = List.singleton(cauchy_seq(a, b)(m))
//                 map(m.suc.range, cauchy_seq(a, b)) = map(m.range, cauchy_seq(a, b)) + List.singleton(cauchy_seq(a, b)(m))
//
//                 from list.list_sum import sum_add
//                 sum_add(map(m.range, cauchy_seq(a, b)), List.singleton(cauchy_seq(a, b)(m)))
//                 sum(map(m.range, cauchy_seq(a, b)) + List.singleton(cauchy_seq(a, b)(m))) = sum(map(m.range, cauchy_seq(a, b))) + sum(List.singleton(cauchy_seq(a, b)(m)))
//                 sum(List.singleton(cauchy_seq(a, b)(m))) = cauchy_seq(a, b)(m)
//
//                 partial(cauchy_seq(a, b), m.suc) = sum(map(m.suc.range, cauchy_seq(a, b)))
//                 partial(cauchy_seq(a, b), m) = sum(map(m.range, cauchy_seq(a, b)))
//                 partial(cauchy_seq(a, b), m.suc) = partial(cauchy_seq(a, b), m) + cauchy_seq(a, b)(m)
//                 cauchy_seq(a, b)(m) = cauchy_product(a, b, m)
//                 partial(cauchy_seq(a, b), m.suc) = partial(cauchy_seq(a, b), m) + cauchy_product(a, b, m)
//
//                 // Expand partial(a, m.suc) and partial(b, m.suc)
//                 map_add(m.range, List.singleton(m), a)
//                 map(m.suc.range, a) = map(m.range, a) + List.singleton(a(m))
//                 sum_add(map(m.range, a), List.singleton(a(m)))
//                 sum(map(m.suc.range, a)) = sum(map(m.range, a)) + a(m)
//                 partial(a, m.suc) = partial(a, m) + a(m)
//
//                 map_add(m.range, List.singleton(m), b)
//                 map(m.suc.range, b) = map(m.range, b) + List.singleton(b(m))
//                 sum_add(map(m.range, b), List.singleton(b(m)))
//                 sum(map(m.suc.range, b)) = sum(map(m.range, b)) + b(m)
//                 partial(b, m.suc) = partial(b, m) + b(m)
//
//                 // Expand the product
//                 partial(a, m.suc) * partial(b, m.suc) = (partial(a, m) + a(m)) * (partial(b, m) + b(m))
//                 (partial(a, m) + a(m)) * (partial(b, m) + b(m)) = partial(a, m) * (partial(b, m) + b(m)) + a(m) * (partial(b, m) + b(m))
//                 partial(a, m) * (partial(b, m) + b(m)) = partial(a, m) * partial(b, m) + partial(a, m) * b(m)
//                 a(m) * (partial(b, m) + b(m)) = a(m) * partial(b, m) + a(m) * b(m)
//                 partial(a, m.suc) * partial(b, m.suc) = partial(a, m) * partial(b, m) + partial(a, m) * b(m) + a(m) * partial(b, m) + a(m) * b(m)
//
//                 // Now we need to show: partial(cauchy_seq(a, b), m) + cauchy_product(a, b, m) <= partial(a, m) * partial(b, m) + partial(a, m) * b(m) + a(m) * partial(b, m) + a(m) * b(m)
//
//                 // By IH and lte_add_left, we can add cauchy_product(a, b, m) to both sides of the IH
//                 lte_add_left(partial(cauchy_seq(a, b), m), partial(a, m) * partial(b, m), cauchy_product(a, b, m))
//                 partial(cauchy_seq(a, b), m) + cauchy_product(a, b, m) <= partial(a, m) * partial(b, m) + cauchy_product(a, b, m)
//
//                 // So it suffices to show: partial(a, m) * partial(b, m) + cauchy_product(a, b, m) <= RHS
//                 // which means: cauchy_product(a, b, m) <= partial(a, m) * b(m) + a(m) * partial(b, m) + a(m) * b(m)
//
//                 // Expand cauchy_product using distributivity over partial sums
//                 // cauchy_product(a, b, m) = sum of a(k) * b(m - k) for k from 0 to m
//
//                 // We'll show this by expanding partial(a, m) * b(m) + a(m) * partial(b, m) + a(m) * b(m)
//                 // and showing it bounds cauchy_product(a, b, m)
//
//                 // The key insight: cauchy_product terms are a(k)*b(m-k) for k in [0..m]
//                 // The RHS expansion provides: a(k)*b(m) for k in [0..m-1], plus a(m)*b(j) for j in [0..m]
//                 // These don't directly match, but we can show the inequality holds using nonnegativity
//
//                 // For now, we'll use a more direct approach: show that the global inequality holds
//                 // by noting that all additional terms beyond the IH are nonnegative
//
//                 // All terms in a and b are nonnegative
//                 forall(i: Nat) {
//                     is_lower_bound(a, Real.0)
//                     a(i) >= Real.0
//                     is_lower_bound(b, Real.0)
//                     b(i) >= Real.0
//                 }
//
//                 // Therefore partial sums are nonnegative
//                 // TODO: Need a lemma that partial of nonnegative sequence is nonnegative
//
//                 // All products of nonnegative terms are nonnegative
//                 a(m) * b(m) >= Real.0
//                 partial(a, m) * b(m) >= Real.0
//                 a(m) * partial(b, m) >= Real.0
//
//                 // TODO: Complete this by showing that the specific arrangement of terms works out
//                 // This requires a more sophisticated approach to handling double sums
//                 sorry
//             }
//             p(m.suc)
//         }
//     }
//
//     p(n)
// }

// TODO: The Cauchy product of two absolutely convergent series converges absolutely.
// This is a key step toward Mertens' theorem.
// theorem cauchy_product_abs_converges(a: Nat -> Real, b: Nat -> Real) {
//     absolutely_converges(a) and absolutely_converges(b)
//     implies
//     absolutely_converges(cauchy_seq(a, b))
// } by {
//     from real.real_series import comparison_test
//
//     if absolutely_converges(a) and absolutely_converges(b) {
//         // abs_fn(a) and abs_fn(b) are nonnegative
//         forall(n: Nat) {
//             abs_fn(a)(n) >= Real.0
//             abs_fn(b)(n) >= Real.0
//         }
//         is_lower_bound(abs_fn(a), Real.0)
//         is_lower_bound(abs_fn(b), Real.0)
//
//         // By the key lemma, partial sums are bounded by product
//         forall(n: Nat) {
//             partial(cauchy_seq(abs_fn(a), abs_fn(b)), n) <= partial(abs_fn(a), n) * partial(abs_fn(b), n)
//         }
//
//         // abs_fn(cauchy_seq(a, b)) is also nonnegative
//         forall(n: Nat) {
//             abs_fn(cauchy_seq(a, b))(n) = cauchy_seq(a, b)(n).abs
//             cauchy_seq(a, b)(n).abs >= Real.0
//         }
//         is_lower_bound(abs_fn(cauchy_seq(a, b)), Real.0)
//
//         // Show that abs_fn(cauchy_seq(a, b)) is bounded by cauchy_seq(abs_fn(a), abs_fn(b))
//         forall(n: Nat) {
//             abs_fn(cauchy_seq(a, b))(n) = cauchy_seq(a, b)(n).abs
//             cauchy_seq(a, b)(n) = cauchy_product(a, b, n)
//             abs_fn(cauchy_seq(a, b))(n) = cauchy_product(a, b, n).abs
//             cauchy_product(a, b, n).abs <= cauchy_product(abs_fn(a), abs_fn(b), n)
//             cauchy_product(abs_fn(a), abs_fn(b), n) = cauchy_seq(abs_fn(a), abs_fn(b))(n)
//             abs_fn(cauchy_seq(a, b))(n) <= cauchy_seq(abs_fn(a), abs_fn(b))(n)
//         }
//         seq_lte(abs_fn(cauchy_seq(a, b)), cauchy_seq(abs_fn(a), abs_fn(b)))
//
//         // TODO: Show that partial(cauchy_seq(abs_fn(a), abs_fn(b))) converges
//         // using the bound and the fact that partial(abs_fn(a)) and partial(abs_fn(b)) converge.
//
//         // Apply comparison test
//         // comparison_test(abs_fn(cauchy_seq(a, b)), cauchy_seq(abs_fn(a), abs_fn(b)))
//         // converges(partial(abs_fn(cauchy_seq(a, b))))
//         // absolutely_converges(cauchy_seq(a, b))
//     }
// }
