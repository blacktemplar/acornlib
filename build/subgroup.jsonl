{"goal":"identity_constraint<G>(is_identity<G>)","proof":["identity_constraint<G>(is_identity<G>) = is_identity(G.1)","not is_identity(G.1)","G.1 != G.1 or is_identity(G.1)"]}
{"goal":"closure_constraint<G>(is_identity<G>)","proof":["let (s0: G -> Bool -> G, s1: G -> Bool -> G) satisfy { forall(x0: G -> Bool, x1: G, x2: G) { not closure_constraint<G>(x0) or not x0(x1) or not x0(x2) or x0(x1 * x2) } and forall(x3: G -> Bool) { closure_constraint<G>(x3) or x3(s0(x3)) } and forall(x4: G -> Bool) { closure_constraint<G>(x4) or x4(s1(x4)) } and forall(x5: G -> Bool) { not x5(s0(x5) * s1(x5)) or closure_constraint<G>(x5) } }","not is_identity(s0(is_identity<G>) * s1(is_identity<G>)) or closure_constraint<G>(is_identity<G>)","not is_identity(s0(is_identity<G>) * s1(is_identity<G>))","closure_constraint<G>(is_identity<G>) or is_identity(s1(is_identity<G>))","is_identity(s1(is_identity<G>))","closure_constraint<G>(is_identity<G>) or is_identity(s0(is_identity<G>))","is_identity(s0(is_identity<G>))","s0(is_identity<G>) * G.1 = s0(is_identity<G>)","not is_identity(s1(is_identity<G>)) or s1(is_identity<G>) = G.1","s1(is_identity<G>) = G.1"]}
{"goal":"inverse_constraint<G>(is_identity<G>)","proof":["let s0: G -> Bool -> G satisfy { forall(x0: G -> Bool, x1: G) { not inverse_constraint<G>(x0) or not x0(x1) or x0(x1.inverse) } and forall(x2: G -> Bool) { inverse_constraint<G>(x2) or x2(s0(x2)) } and forall(x3: G -> Bool) { not x3(s0(x3).inverse) or inverse_constraint<G>(x3) } }","not is_identity(s0(is_identity<G>).inverse) or inverse_constraint<G>(is_identity<G>)","not is_identity(s0(is_identity<G>).inverse)","s0(is_identity<G>) * s0(is_identity<G>).inverse = G.1","inverse_constraint<G>(is_identity<G>) or is_identity(s0(is_identity<G>))","is_identity(s0(is_identity<G>))","identity_constraint<G>(is_identity<G>) = is_identity(G.1)","is_identity(G.1)","not is_identity(s0(is_identity<G>)) or s0(is_identity<G>) = G.1","G.1 * s0(is_identity<G>).inverse = s0(is_identity<G>).inverse","is_identity(s0(is_identity<G>) * s0(is_identity<G>).inverse)","s0(is_identity<G>) = G.1","not is_identity(G.1 * s0(is_identity<G>).inverse)"]}
{"goal":"identity_subgroup_constraint","proof":["not inverse_constraint<G>(is_identity<G>) or not identity_constraint<G>(is_identity<G>) or not closure_constraint<G>(is_identity<G>) or subgroup_constraint<G>(is_identity<G>)"]}
{"goal":"exists(k0: G -> Bool) { subgroup_constraint<G>(k0) }","proof":["not subgroup_constraint<G>(is_identity<G>)"]}
{"goal":"identity_subgroup_only_has_identity","proof":["not Subgroup.new<G>(is_identity<G>).contains(g) or not subgroup_constraint<G>(is_identity<G>) or is_identity(g)","not is_identity(g) or G.1 = g","not is_identity(g)","Subgroup.new<G>(is_identity<G>).contains(g)","not Subgroup.new<G>(is_identity<G>).contains(g)"]}
