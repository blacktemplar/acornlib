{"goal":"partial[A](f, 1) = sum[A](map[Nat, A](1.range, f))","proof":["sum[A](map[Nat, A](1.range, f)) = partial[A](f, 1)"]}
{"goal":"1.range = 0.range.append(0)","proof":["0.suc != 1 or 0.range.append(0) = 1.range","0.suc != 1"]}
{"goal":"0.range = List.nil[Nat]","proof":["0 != 0 or 0.range = List.nil[Nat]"]}
{"goal":"1.range = List.singleton(0)","proof":["0.range + List.singleton(0) = 0.range.append(0)","List.cons(0, List.nil[Nat]) = List.singleton(0)","List.nil[Nat] + List.cons(0, List.nil[Nat]) = List.cons(0, List.nil[Nat])"]}
{"goal":"map[Nat, A](1.range, f) = map[Nat, A](List.singleton(0), f)","proof":["1.range != List.singleton(0)"]}
{"goal":"map[Nat, A](List.singleton(0), f) = List.singleton(f(0))","proof":["List.cons(0, List.nil[Nat]) != List.cons(0, List.nil[Nat]) or List.cons(f(0), map[Nat, A](List.nil[Nat], f)) = map[Nat, A](List.cons(0, List.nil[Nat]), f)","List.nil[Nat] != List.nil[Nat] or map[Nat, A](List.nil[Nat], f) = List.nil[A]","List.cons(0, List.nil[Nat]) = List.singleton(0)","List.cons(f(0), List.nil[A]) = List.singleton(f(0))","map[Nat, A](List.cons(0, List.nil[Nat]), f) != List.singleton(f(0))","map[Nat, A](List.nil[Nat], f) = List.nil[A]","List.cons(f(0), map[Nat, A](List.nil[Nat], f)) = map[Nat, A](List.cons(0, List.nil[Nat]), f)","List.cons(f(0), map[Nat, A](List.nil[Nat], f)) != List.singleton(f(0))"]}
{"goal":"sum[A](List.singleton(f(0))) = sum[A](List.cons(f(0), List.nil[A]))","proof":["List.cons(f(0), List.nil[A]) != List.singleton(f(0))","List.cons(f(0), List.nil[A]) = List.singleton(f(0))"]}
{"goal":"sum[A](List.cons(f(0), List.nil[A])) = f(0) + sum[A](List.nil[A])","proof":["List.cons(f(0), List.nil[A]) != List.cons(f(0), List.nil[A]) or f(0) + sum[A](List.nil[A]) = sum[A](List.cons(f(0), List.nil[A]))"]}
{"goal":"sum[A](List.nil[A]) = A.0","proof":["List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0"]}
{"goal":"f(0) + A.0 = f(0)","proof":["f(0) + A.0 = f(0)"]}
{"goal":"partial_one","proof":[]}
{"goal":"sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) = A.0 + A.0","proof":["List.nil[T] != List.nil[T] or map[T, A](List.nil[T], f) = List.nil[A]","List.nil[T] != List.nil[T] or map[T, A](List.nil[T], g) = List.nil[A]","sum[A](map[T, A](List.nil[T], g)) + sum[A](map[T, A](List.nil[T], f)) = sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g))","List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0","A.0 + A.0 = A.0","sum[A](map[T, A](List.nil[T], g)) + A.0 = sum[A](map[T, A](List.nil[T], g))","sum[A](List.nil[A]) = A.0","map[T, A](List.nil[T], f) = List.nil[A]","map[T, A](List.nil[T], g) = List.nil[A]"]}
{"goal":"A.0 + A.0 = A.0","proof":["A.0 + A.0 = A.0"]}
{"goal":"sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g))) = A.0","proof":["List.nil[T] != List.nil[T] or map[T, A](List.nil[T], add_fn[T, A](f, g)) = List.nil[A]","map[T, A](List.nil[T], add_fn[T, A](f, g)) != List.nil[A] or sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g))) = A.0","map[T, A](List.nil[T], add_fn[T, A](f, g)) != List.nil[A]"]}
{"goal":"p(List.nil[T])","proof":["sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) != sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g))) or p(List.nil[T])","A.0 + A.0 = A.0","sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) = A.0","sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) != sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g)))","sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) = sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g)))"]}
{"goal":"sum[A](map[T, A](List.cons(head, tail), f)) = sum[A](List.cons(f(head), map[T, A](tail, f)))","proof":["List.cons(f(head), map[T, A](tail, f)) != map[T, A](List.cons(head, tail), f)","List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, A](tail, f)) = map[T, A](List.cons(head, tail), f)"]}
{"goal":"sum[A](List.cons(f(head), map[T, A](tail, f))) = f(head) + sum[A](map[T, A](tail, f))","proof":["List.cons(f(head), map[T, A](tail, f)) != List.cons(f(head), map[T, A](tail, f)) or sum[A](List.cons(f(head), map[T, A](tail, f))) = f(head) + sum[A](map[T, A](tail, f))"]}
{"goal":"sum[A](map[T, A](List.cons(head, tail), g)) = sum[A](List.cons(g(head), map[T, A](tail, g)))","proof":["List.cons(g(head), map[T, A](tail, g)) != map[T, A](List.cons(head, tail), g)","List.cons(head, tail) != List.cons(head, tail) or List.cons(g(head), map[T, A](tail, g)) = map[T, A](List.cons(head, tail), g)"]}
{"goal":"sum[A](List.cons(g(head), map[T, A](tail, g))) = g(head) + sum[A](map[T, A](tail, g))","proof":["List.cons(g(head), map[T, A](tail, g)) != List.cons(g(head), map[T, A](tail, g)) or sum[A](List.cons(g(head), map[T, A](tail, g))) = g(head) + sum[A](map[T, A](tail, g))"]}
{"goal":"map[T, A](List.cons(head, tail), add_fn[T, A](f, g)) = List.cons(add_fn[T, A](f, g)(head), map[T, A](tail, add_fn[T, A](f, g)))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(add_fn[T, A](f, g, head), map[T, A](tail, add_fn[T, A](f, g))) = map[T, A](List.cons(head, tail), add_fn[T, A](f, g))","List.cons(add_fn[T, A](f, g, head), map[T, A](tail, add_fn[T, A](f, g))) = map[T, A](List.cons(head, tail), add_fn[T, A](f, g))"]}
{"goal":"add_fn[T, A](f, g)(head) = f(head) + g(head)","proof":["f(head) + g(head) = add_fn[T, A](f, g, head)"]}
{"goal":"sum[A](map[T, A](List.cons(head, tail), add_fn[T, A](f, g))) = sum[A](List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g))))","proof":[]}
{"goal":"sum[A](List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g)))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))","proof":["List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g))) != List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g))) or sum[A](List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g)))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))"]}
{"goal":"sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = sum[A](map[T, A](tail, add_fn[T, A](f, g)))","proof":["not p(tail) or sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = sum[A](map[T, A](tail, add_fn[T, A](f, g)))"]}
{"goal":"f(head) + sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = f(head) + (sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))))","proof":["f(head) + sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = f(head) + (sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))))"]}
{"goal":"f(head) + (sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g)))) = f(head) + (sum[A](map[T, A](tail, f)) + g(head) + sum[A](map[T, A](tail, g)))","proof":["sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) != sum[A](map[T, A](tail, f)) + g(head) + sum[A](map[T, A](tail, g))","sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = sum[A](map[T, A](tail, f)) + g(head) + sum[A](map[T, A](tail, g))"]}
{"goal":"f(head) + (sum[A](map[T, A](tail, f)) + g(head) + sum[A](map[T, A](tail, g))) = f(head) + (g(head) + sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","proof":["sum[A](map[T, A](tail, f)) + g(head) = g(head) + sum[A](map[T, A](tail, f))"]}
{"goal":"f(head) + (g(head) + sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))) = f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))))","proof":["g(head) + sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) != g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","g(head) + sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))"]}
{"goal":"f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))) = f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","proof":["f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))) = f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))))"]}
{"goal":"f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))","proof":["sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) != sum[A](map[T, A](tail, add_fn[T, A](f, g)))"]}
{"goal":"p(List.cons(head, tail))","proof":["sum[A](map[T, A](List.cons(head, tail), f)) + sum[A](map[T, A](List.cons(head, tail), g)) != sum[A](map[T, A](List.cons(head, tail), add_fn[T, A](f, g))) or p(List.cons(head, tail))","sum[A](map[T, A](List.cons(head, tail), f)) + sum[A](map[T, A](List.cons(head, tail), g)) != sum[A](map[T, A](List.cons(head, tail), add_fn[T, A](f, g)))"]}
{"goal":"map_sum_add","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(list) or sum[A](map[T, A](list, f)) + sum[A](map[T, A](list, g)) = sum[A](map[T, A](list, add_fn[T, A](f, g)))","not p(list)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p))) or p(list)","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"partial[A](f, n) = sum[A](map[Nat, A](n.range, f))","proof":["sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)"]}
{"goal":"partial[A](g, n) = sum[A](map[Nat, A](n.range, g))","proof":["sum[A](map[Nat, A](n.range, g)) = partial[A](g, n)"]}
{"goal":"partial[A](add_fn[Nat, A](f, g), n) = sum[A](map[Nat, A](n.range, add_fn[Nat, A](f, g)))","proof":["sum[A](map[Nat, A](n.range, add_fn[Nat, A](f, g))) = partial[A](add_fn[Nat, A](f, g), n)"]}
{"goal":"sum[A](map[Nat, A](n.range, f)) + sum[A](map[Nat, A](n.range, g)) = sum[A](map[Nat, A](n.range, add_fn[Nat, A](f, g)))","proof":["sum[A](map[Nat, A](n.range, f)) + sum[A](map[Nat, A](n.range, g)) = sum[A](map[Nat, A](n.range, add_fn[Nat, A](f, g)))"]}
{"goal":"partial_add","proof":[]}
{"goal":"sum[S](List.nil[S]) = S.0","proof":["List.nil[S] != List.nil[S] or sum[S](List.nil[S]) = S.0"]}
{"goal":"c * S.0 = S.0","proof":["c * S.0 = S.0"]}
{"goal":"map[S, S](List.nil[S], scalar_mul(c)) = List.nil[S]","proof":["List.nil[S].map(scalar_mul(c)) = map[S, S](List.nil[S], scalar_mul(c))","List.nil[S].map(scalar_mul(c)) != List.nil[S]","List.nil[S] != List.nil[S] or List.nil[S].map(scalar_mul(c)) = List.nil[S]"]}
{"goal":"sum[S](List.nil[S]) = S.0","proof":[]}
{"goal":"p(List.nil[S])","proof":["sum[S](map[S, S](List.nil[S], scalar_mul(c))) != c * sum[S](List.nil[S]) or p(List.nil[S])","sum[S](map[S, S](List.nil[S], scalar_mul(c))) != c * sum[S](List.nil[S])"]}
{"goal":"sum[S](List.cons(head, tail)) = head + sum[S](tail)","proof":["List.cons(head, tail) != List.cons(head, tail) or sum[S](List.cons(head, tail)) = head + sum[S](tail)"]}
{"goal":"c * sum[S](List.cons(head, tail)) = c * (head + sum[S](tail))","proof":["sum[S](List.cons(head, tail)) != head + sum[S](tail)"]}
{"goal":"c * (head + sum[S](tail)) = c * head + c * sum[S](tail)","proof":["c * head + c * sum[S](tail) = c * (head + sum[S](tail))"]}
{"goal":"c * sum[S](tail) = sum[S](map[S, S](tail, scalar_mul(c)))","proof":["not p(tail) or sum[S](map[S, S](tail, scalar_mul(c))) = c * sum[S](tail)"]}
{"goal":"c * head + c * sum[S](tail) = c * head + sum[S](map[S, S](tail, scalar_mul(c)))","proof":["sum[S](map[S, S](tail, scalar_mul(c))) != c * sum[S](tail)"]}
{"goal":"map[S, S](List.cons(head, tail), scalar_mul(c)) = List.cons(scalar_mul(c)(head), map[S, S](tail, scalar_mul(c)))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c))) = map[S, S](List.cons(head, tail), scalar_mul(c))","List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c))) = map[S, S](List.cons(head, tail), scalar_mul(c))"]}
{"goal":"scalar_mul(c)(head) = c * head","proof":["scalar_mul(c, head) = c * head"]}
{"goal":"map[S, S](List.cons(head, tail), scalar_mul(c)) = List.cons(c * head, map[S, S](tail, scalar_mul(c)))","proof":["List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c))) != map[S, S](List.cons(head, tail), scalar_mul(c))"]}
{"goal":"sum[S](map[S, S](List.cons(head, tail), scalar_mul(c))) = sum[S](List.cons(c * head, map[S, S](tail, scalar_mul(c))))","proof":["List.cons(c * head, map[S, S](tail, scalar_mul(c))) != map[S, S](List.cons(head, tail), scalar_mul(c))"]}
{"goal":"sum[S](List.cons(c * head, map[S, S](tail, scalar_mul(c)))) = c * head + sum[S](map[S, S](tail, scalar_mul(c)))","proof":["c * head + sum[S](map[S, S](tail, scalar_mul(c))) != sum[S](map[S, S](List.cons(head, tail), scalar_mul(c)))","List.cons(c * head, map[S, S](tail, scalar_mul(c))) != map[S, S](List.cons(head, tail), scalar_mul(c)) or c * head + sum[S](map[S, S](tail, scalar_mul(c))) = sum[S](map[S, S](List.cons(head, tail), scalar_mul(c)))"]}
{"goal":"c * sum[S](List.cons(head, tail)) = sum[S](map[S, S](List.cons(head, tail), scalar_mul(c)))","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["sum[S](map[S, S](List.cons(head, tail), scalar_mul(c))) != c * sum[S](List.cons(head, tail)) or p(List.cons(head, tail))","sum[S](map[S, S](List.cons(head, tail), scalar_mul(c))) != c * sum[S](List.cons(head, tail))"]}
{"goal":"sum_scalar_mul","proof":["let (s0: List[S] -> Bool -> S, s1: List[S] -> Bool -> List[S]) satisfy { forall(x0: List[S] -> Bool, x1: List[S]) { not x0(List.nil[S]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[S] -> Bool, x3: List[S]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[S]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(list) or sum[S](map[S, S](list, scalar_mul(c))) = c * sum[S](list)","not p(list)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[S]) or p(list)","not p(List.nil[S]) or p(s1(p)) or p(list)","p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p))) or p(list)","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"sum[A](List.nil[A] + right) = sum[A](right)","proof":["List.nil[A] + right != right","List.nil[A] != List.nil[A] or List.nil[A] + right = right"]}
{"goal":"sum[A](List.nil[A]) = A.0","proof":["List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0"]}
{"goal":"A.0 + sum[A](right) = sum[A](right)","proof":["sum[A](right) + A.0 = A.0 + sum[A](right)","sum[A](right) + A.0 != sum[A](right)","sum[A](right) + A.0 = sum[A](right)"]}
{"goal":"p(List.nil[A])","proof":["sum[A](List.nil[A]) + sum[A](right) != sum[A](List.nil[A] + right) or p(List.nil[A])","sum[A](List.nil[A]) + sum[A](right) != sum[A](List.nil[A] + right)"]}
{"goal":"sum[A](List.cons(head, tail) + right) = sum[A](List.cons(head, tail + right))","proof":["List.cons(head, tail) + right != List.cons(head, tail + right)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + right = List.cons(head, tail + right)"]}
{"goal":"sum[A](List.cons(head, tail + right)) = head + sum[A](tail + right)","proof":["List.cons(head, tail + right) != List.cons(head, tail + right) or head + sum[A](tail + right) = sum[A](List.cons(head, tail + right))"]}
{"goal":"head + sum[A](tail + right) = head + (sum[A](tail) + sum[A](right))","proof":["not p(tail) or sum[A](tail) + sum[A](right) = sum[A](tail + right)","sum[A](tail) + sum[A](right) != sum[A](tail + right)","sum[A](tail) + sum[A](right) = sum[A](tail + right)"]}
{"goal":"sum[A](List.cons(head, tail)) = head + sum[A](tail)","proof":["List.cons(head, tail) != List.cons(head, tail) or head + sum[A](tail) = sum[A](List.cons(head, tail))"]}
{"goal":"sum[A](List.cons(head, tail)) + sum[A](right) = head + sum[A](tail) + sum[A](right)","proof":["head + sum[A](tail) != sum[A](List.cons(head, tail))"]}
{"goal":"head + sum[A](tail) + sum[A](right) = head + (sum[A](tail) + sum[A](right))","proof":["head + sum[A](tail) + sum[A](right) = head + (sum[A](tail) + sum[A](right))"]}
{"goal":"sum[A](List.cons(head, tail) + right) = sum[A](List.cons(head, tail)) + sum[A](right)","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["sum[A](List.cons(head, tail)) + sum[A](right) != sum[A](List.cons(head, tail) + right) or p(List.cons(head, tail))","sum[A](List.cons(head, tail)) + sum[A](right) != sum[A](List.cons(head, tail) + right)"]}
{"goal":"sum_add","proof":["let (s0: List[A] -> Bool -> A, s1: List[A] -> Bool -> List[A]) satisfy { forall(x0: List[A] -> Bool, x1: List[A]) { not x0(List.nil[A]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[A] -> Bool, x3: List[A]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[A]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(left) or sum[A](left) + sum[A](right) = sum[A](left + right)","not p(left)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[A]) or p(left)","not p(List.nil[A]) or p(s1(p)) or p(left)","p(s1(p)) or p(left)","p(s1(p))","not p(List.cons(s0(p), s1(p))) or p(left)","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"map[T, U](List.nil[T] + right, f) = map[T, U](right, f)","proof":["List.nil[T] + right != right","List.nil[T] != List.nil[T] or List.nil[T] + right = right"]}
{"goal":"map[T, U](List.nil[T], f) = List.nil[U]","proof":["List.nil[T].map(f) = map[T, U](List.nil[T], f)","List.nil[T].map(f) != List.nil[U]","List.nil[T] != List.nil[T] or List.nil[T].map(f) = List.nil[U]"]}
{"goal":"List.nil[U] + map[T, U](right, f) = map[T, U](right, f)","proof":["List.nil[U] != List.nil[U] or List.nil[U] + map[T, U](right, f) = map[T, U](right, f)"]}
{"goal":"p(List.nil[T])","proof":["map[T, U](List.nil[T], f) + map[T, U](right, f) != map[T, U](List.nil[T] + right, f) or p(List.nil[T])","map[T, U](List.nil[T], f) + map[T, U](right, f) != map[T, U](List.nil[T] + right, f)"]}
{"goal":"map[T, U](List.cons(head, tail) + right, f) = map[T, U](List.cons(head, tail + right), f)","proof":["List.cons(head, tail) + right != List.cons(head, tail + right)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + right = List.cons(head, tail + right)"]}
{"goal":"map[T, U](List.cons(head, tail + right), f) = List.cons(f(head), map[T, U](tail + right, f))","proof":["List.cons(head, tail + right) != List.cons(head, tail + right) or List.cons(f(head), map[T, U](tail + right, f)) = map[T, U](List.cons(head, tail + right), f)"]}
{"goal":"List.cons(f(head), map[T, U](tail + right, f)) = List.cons(f(head), map[T, U](tail, f) + map[T, U](right, f))","proof":["not p(tail) or map[T, U](tail, f) + map[T, U](right, f) = map[T, U](tail + right, f)","map[T, U](tail, f) + map[T, U](right, f) != map[T, U](tail + right, f)","map[T, U](tail, f) + map[T, U](right, f) = map[T, U](tail + right, f)"]}
{"goal":"map[T, U](List.cons(head, tail), f) = List.cons(f(head), map[T, U](tail, f))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"map[T, U](List.cons(head, tail), f) + map[T, U](right, f) = List.cons(f(head), map[T, U](tail, f)) + map[T, U](right, f)","proof":["List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) + map[T, U](right, f) = List.cons(f(head), map[T, U](tail, f) + map[T, U](right, f))","proof":["List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or List.cons(f(head), map[T, U](tail, f)) + map[T, U](right, f) = List.cons(f(head), map[T, U](tail, f) + map[T, U](right, f))"]}
{"goal":"map[T, U](List.cons(head, tail) + right, f) = map[T, U](List.cons(head, tail), f) + map[T, U](right, f)","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["map[T, U](List.cons(head, tail), f) + map[T, U](right, f) != map[T, U](List.cons(head, tail) + right, f) or p(List.cons(head, tail))","map[T, U](List.cons(head, tail), f) + map[T, U](right, f) != map[T, U](List.cons(head, tail) + right, f)"]}
{"goal":"map_add","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(left) or map[T, U](left, f) + map[T, U](right, f) = map[T, U](left + right, f)","not p(left)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(left)","not p(List.nil[T]) or p(s1(p)) or p(left)","p(s1(p)) or p(left)","p(s1(p))","not p(List.cons(s0(p), s1(p))) or p(left)","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"map_append","proof":["List.cons(last, List.nil[T]) != List.cons(last, List.nil[T]) or List.cons(f(last), map[T, U](List.nil[T], f)) = map[T, U](List.cons(last, List.nil[T]), f)","map[T, U](initial, f) + map[T, U](List.singleton(last), f) = map[T, U](initial + List.singleton(last), f)","map[T, U](initial, f) + List.singleton(f(last)) = map[T, U](initial, f).append(f(last))","initial + List.singleton(last) = initial.append(last)","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","List.cons(f(last), List.nil[U]) = List.singleton(f(last))","List.cons(last, List.nil[T]) = List.singleton(last)","map[T, U](List.nil[T], f) = List.nil[U]","List.cons(f(last), map[T, U](List.nil[T], f)) = map[T, U](List.cons(last, List.nil[T]), f)","map[T, U](initial, f).append(f(last)) != map[T, U](initial + List.singleton(last), f)","map[T, U](initial, f) + map[T, U](List.singleton(last), f) != map[T, U](initial, f).append(f(last))","map[T, U](initial, f) + map[T, U](List.singleton(last), f) != map[T, U](initial, f) + List.singleton(f(last))","map[T, U](List.singleton(last), f) != List.singleton(f(last))"]}
{"goal":"sum_append","proof":["List.cons(last, List.nil[A]) != List.cons(last, List.nil[A]) or last + sum[A](List.nil[A]) = sum[A](List.cons(last, List.nil[A]))","sum[A](initial) + sum[A](List.singleton(last)) = sum[A](initial + List.singleton(last))","initial + List.singleton(last) = initial.append(last)","List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0","List.cons(last, List.nil[A]) = List.singleton(last)","last + A.0 = last","sum[A](List.nil[A]) = A.0","sum[A](initial + List.singleton(last)) != sum[A](initial) + last","last + sum[A](List.nil[A]) = sum[A](List.cons(last, List.nil[A]))","sum[A](initial) + sum[A](List.singleton(last)) != sum[A](initial) + last","sum[A](List.singleton(last)) != last"]}
{"goal":"List.nil[T] + b + c = b + c","proof":["List.nil[T] + b != b","List.nil[T] != List.nil[T] or List.nil[T] + b = b"]}
{"goal":"List.nil[T] + (b + c) = b + c","proof":["List.nil[T] != List.nil[T] or List.nil[T] + (b + c) = b + c"]}
{"goal":"p(List.nil[T])","proof":["List.nil[T] + b + c != List.nil[T] + (b + c) or p(List.nil[T])","List.nil[T] + b + c = List.nil[T] + (b + c)","List.nil[T] + b + c != List.nil[T] + (b + c)"]}
{"goal":"List.cons(head, tail) + b + c = List.cons(head, tail + b) + c","proof":["List.cons(head, tail) + b != List.cons(head, tail + b)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + b = List.cons(head, tail + b)"]}
{"goal":"List.cons(head, tail + b) + c = List.cons(head, tail + b + c)","proof":["List.cons(head, tail + b) != List.cons(head, tail + b) or List.cons(head, tail + b) + c = List.cons(head, tail + b + c)"]}
{"goal":"List.cons(head, tail + b + c) = List.cons(head, tail + (b + c))","proof":["not p(tail) or tail + b + c = tail + (b + c)","tail + b + c != tail + (b + c)","tail + b + c = tail + (b + c)"]}
{"goal":"List.cons(head, tail) + (b + c) = List.cons(head, tail + (b + c))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + (b + c) = List.cons(head, tail + (b + c))"]}
{"goal":"List.cons(head, tail) + b + c = List.cons(head, tail) + (b + c)","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail) + b + c != List.cons(head, tail) + (b + c) or p(List.cons(head, tail))","List.cons(head, tail) + b + c != List.cons(head, tail) + (b + c)"]}
{"goal":"add_assoc","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(a) or a + b + c = a + (b + c)","not p(a)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)","p(s1(p)) or p(a)","p(s1(p))","not p(List.cons(s0(p), s1(p))) or p(a)","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"map_singleton","proof":["List.cons(x, List.nil[T]) != List.cons(x, List.nil[T]) or List.cons(f(x), map[T, U](List.nil[T], f)) = map[T, U](List.cons(x, List.nil[T]), f)","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","List.cons(f(x), List.nil[U]) = List.singleton(f(x))","List.cons(x, List.nil[T]) = List.singleton(x)","map[T, U](List.cons(x, List.nil[T]), f) != List.singleton(f(x))","map[T, U](List.nil[T], f) = List.nil[U]","List.cons(f(x), map[T, U](List.nil[T], f)) = map[T, U](List.cons(x, List.nil[T]), f)","List.cons(f(x), map[T, U](List.nil[T], f)) != List.singleton(f(x))"]}
{"goal":"length_zero_imp_nil","proof":["let (s0: List[T] -> T, s1: List[T] -> List[T]) satisfy { forall(x0: List[T]) { List.cons(s0(x0), s1(x0)) = x0 or List.nil[T] = x0 } }","List.cons(s0(list), s1(list)) != list or s1(list).length.suc = list.length","List.cons(s0(list), s1(list)) = list or List.nil[T] = list","List.cons(s0(list), s1(list)) = list","s1(list).length.suc != 0","s1(list).length.suc = list.length"]}
{"goal":"add_to_nil","proof":["a.length + b.length = (a + b).length","a.length + b.length != 0 or b.length = 0","a.length + b.length != 0 or a.length = 0","a.length != 0 or List.nil[T] = a","b.length != 0 or List.nil[T] = b","a + b != List.nil[T] or (a + b).length = 0","(a + b).length = 0","a.length + b.length = 0","a.length = 0","b.length = 0","List.nil[T] = b","List.nil[T] = a","List.nil[T] != a"]}
{"goal":"append_not_nil","proof":["a + List.singleton(t) = a.append(t)","a + List.singleton(t) = List.nil[T]","a + List.singleton(t) != List.nil[T] or List.singleton(t) = List.nil[T]","List.cons(t, List.nil[T]) = List.singleton(t)","List.cons(t, List.nil[T]) != List.nil[T]","List.singleton(t) = List.nil[T]"]}
{"goal":"map[U, V](map[T, U](List.nil[T], f), g) = map[U, V](List.nil[U], g)","proof":["map[T, U](List.nil[T], f) != List.nil[U]","List.nil[T].map(f) = map[T, U](List.nil[T], f)","List.nil[T].map(f) != List.nil[U]","List.nil[T] != List.nil[T] or List.nil[T].map(f) = List.nil[U]"]}
{"goal":"map[U, V](List.nil[U], g) = List.nil[V]","proof":["List.nil[U].map(g) = map[U, V](List.nil[U], g)","List.nil[U].map(g) != List.nil[V]","List.nil[U] != List.nil[U] or List.nil[U].map(g) = List.nil[V]"]}
{"goal":"map[T, V](List.nil[T], compose[T, U, V](g, f)) = List.nil[V]","proof":["List.nil[T] != List.nil[T] or map[T, V](List.nil[T], compose[T, U, V](g, f)) = List.nil[V]"]}
{"goal":"p(List.nil[T])","proof":["map[T, V](List.nil[T], compose[T, U, V](g, f)) != map[U, V](map[T, U](List.nil[T], f), g) or p(List.nil[T])","map[U, V](map[T, U](List.nil[T], f), g) = List.nil[V]","map[T, V](List.nil[T], compose[T, U, V](g, f)) != map[U, V](map[T, U](List.nil[T], f), g)","map[T, V](List.nil[T], compose[T, U, V](g, f)) = map[U, V](map[T, U](List.nil[T], f), g)"]}
{"goal":"map[U, V](map[T, U](List.cons(head, tail), f), g) = map[U, V](List.cons(f(head), map[T, U](tail, f)), g)","proof":["List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f)","List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"map[U, V](List.cons(f(head), map[T, U](tail, f)), g) = List.cons(g(f(head)), map[U, V](map[T, U](tail, f), g))","proof":["List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or List.cons(g(f(head)), map[U, V](map[T, U](tail, f), g)) = map[U, V](List.cons(f(head), map[T, U](tail, f)), g)"]}
{"goal":"map[U, V](map[T, U](tail, f), g) = map[T, V](tail, compose[T, U, V](g, f))","proof":["not p(tail) or map[T, V](tail, compose[T, U, V](g, f)) = map[U, V](map[T, U](tail, f), g)"]}
{"goal":"map[T, V](List.cons(head, tail), compose[T, U, V](g, f)) = List.cons(compose[T, U, V](g, f)(head), map[T, V](tail, compose[T, U, V](g, f)))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(compose[T, U, V](g, f, head), map[T, V](tail, compose[T, U, V](g, f))) = map[T, V](List.cons(head, tail), compose[T, U, V](g, f))","List.cons(compose[T, U, V](g, f, head), map[T, V](tail, compose[T, U, V](g, f))) = map[T, V](List.cons(head, tail), compose[T, U, V](g, f))"]}
{"goal":"List.cons(compose[T, U, V](g, f)(head), map[T, V](tail, compose[T, U, V](g, f))) = List.cons(g(f(head)), map[T, V](tail, compose[T, U, V](g, f)))","proof":["compose[T, U, V](g, f, head) != g(f(head))","compose[T, U, V](g, f, head) = g(f(head))"]}
{"goal":"map[U, V](map[T, U](List.cons(head, tail), f), g) = map[T, V](List.cons(head, tail), compose[T, U, V](g, f))","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["map[T, V](List.cons(head, tail), compose[T, U, V](g, f)) != map[U, V](map[T, U](List.cons(head, tail), f), g) or p(List.cons(head, tail))","map[T, V](List.cons(head, tail), compose[T, U, V](g, f)) != map[U, V](map[T, U](List.cons(head, tail), f), g)"]}
{"goal":"map_map","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(items) or map[T, V](items, compose[T, U, V](g, f)) = map[U, V](map[T, U](items, f), g)","not p(items)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(items)","not p(List.nil[T]) or p(s1(p)) or p(items)","p(s1(p)) or p(items)","p(s1(p))","not p(List.cons(s0(p), s1(p))) or p(items)","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"partial[S](f, n) = sum[S](map[Nat, S](n.range, f))","proof":["sum[S](map[Nat, S](n.range, f)) = partial[S](f, n)"]}
{"goal":"c * partial[S](f, n) = c * sum[S](map[Nat, S](n.range, f))","proof":["sum[S](map[Nat, S](n.range, f)) != partial[S](f, n)"]}
{"goal":"c * sum[S](map[Nat, S](n.range, f)) = sum[S](map[S, S](map[Nat, S](n.range, f), scalar_mul(c)))","proof":["sum[S](map[S, S](map[Nat, S](n.range, f), scalar_mul(c))) = c * sum[S](map[Nat, S](n.range, f))"]}
{"goal":"map[S, S](map[Nat, S](n.range, f), scalar_mul(c)) = map[Nat, S](n.range, compose[Nat, S, S](scalar_mul(c), f))","proof":["map[Nat, S](n.range, compose[Nat, S, S](scalar_mul(c), f)) = map[S, S](map[Nat, S](n.range, f), scalar_mul(c))"]}
{"goal":"compose[Nat, S, S](scalar_mul(c), f)(k) = scalar_mul(c)(f(k))","proof":["compose[Nat, S, S](scalar_mul(c), f, k) = scalar_mul(c, f(k))"]}
{"goal":"scalar_mul(c)(f(k)) = c * f(k)","proof":["scalar_mul(c, f(k)) = c * f(k)"]}
{"goal":"mul_fn[Nat, S](c, f)(k) = c * f(k)","proof":["mul_fn(c, f, k) = c * f(k)"]}
{"goal":"compose[Nat, S, S](scalar_mul(c), f)(k) = mul_fn[Nat, S](c, f)(k)","proof":[]}
{"goal":"compose[Nat, S, S](scalar_mul(c), f) = mul_fn[Nat, S](c, f)","proof":["let s0: Nat satisfy { compose[Nat, S, S](scalar_mul(c), f, s0) != mul_fn(c, f, s0) }","compose[Nat, S, S](scalar_mul(c), f, s0) = mul_fn(c, f, s0)"]}
{"goal":"map[Nat, S](n.range, compose[Nat, S, S](scalar_mul(c), f)) = map[Nat, S](n.range, mul_fn[Nat, S](c, f))","proof":["compose[Nat, S, S](scalar_mul(c), f) != mul_fn[Nat, S](c, f)"]}
{"goal":"sum[S](map[S, S](map[Nat, S](n.range, f), scalar_mul(c))) = sum[S](map[Nat, S](n.range, mul_fn[Nat, S](c, f)))","proof":[]}
{"goal":"partial[S](mul_fn[Nat, S](c, f), n) = sum[S](map[Nat, S](n.range, mul_fn[Nat, S](c, f)))","proof":["sum[S](map[Nat, S](n.range, mul_fn[Nat, S](c, f))) = partial[S](mul_fn[Nat, S](c, f), n)"]}
{"goal":"partial_scalar_mul","proof":[]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) = sum[A](map[Nat, A](0.range, compose[Nat, Nat, A](f, Nat.suc)))","proof":["sum[A](map[Nat, A](0.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), 0)"]}
{"goal":"0.range = List.nil[Nat]","proof":["0 != 0 or 0.range = List.nil[Nat]"]}
{"goal":"map[Nat, A](List.nil[Nat], compose[Nat, Nat, A](f, Nat.suc)) = List.nil[A]","proof":["List.nil[Nat] != List.nil[Nat] or map[Nat, A](List.nil[Nat], compose[Nat, Nat, A](f, Nat.suc)) = List.nil[A]"]}
{"goal":"sum[A](List.nil[A]) = A.0","proof":["List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0"]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) = A.0","proof":[]}
{"goal":"f(0) + A.0 = f(0)","proof":["f(0) + A.0 = f(0)"]}
{"goal":"partial[A](f, 0.suc) = partial[A](f, 1)","proof":["0.suc != 1"]}
{"goal":"partial[A](f, 1) = sum[A](map[Nat, A](1.range, f))","proof":["sum[A](map[Nat, A](1.range, f)) = partial[A](f, 1)"]}
{"goal":"1.range = 0.range.append(0)","proof":["0.suc != 1 or 0.range.append(0) = 1.range","0.suc != 1"]}
{"goal":"map[Nat, A](1.range, f) = map[Nat, A](0.range.append(0), f)","proof":["0.range.append(0) != 1.range"]}
{"goal":"map[Nat, A](0.range.append(0), f) = map[Nat, A](0.range, f).append(f(0))","proof":["map[Nat, A](0.range, f).append(f(0)) = map[Nat, A](0.range.append(0), f)"]}
{"goal":"map[Nat, A](0.range, f) = List.nil[A]","proof":["0.range.map(f) = map[Nat, A](0.range, f)","0.range.map(f) != List.nil[A]","0.range != List.nil[Nat] or 0.range.map(f) = List.nil[A]"]}
{"goal":"map[Nat, A](0.range.append(0), f) = List.nil[A].append(f(0))","proof":["map[Nat, A](0.range, f).append(f(0)) != map[Nat, A](0.range.append(0), f)"]}
{"goal":"sum[A](List.nil[A].append(f(0))) = sum[A](List.nil[A]) + f(0)","proof":["sum[A](List.nil[A].append(f(0))) = sum[A](List.nil[A]) + f(0)"]}
{"goal":"sum[A](List.nil[A]) = A.0","proof":[]}
{"goal":"A.0 + f(0) = f(0)","proof":["A.0 + f(0) = f(0) + A.0"]}
{"goal":"sum[A](List.nil[A].append(f(0))) = f(0)","proof":[]}
{"goal":"partial[A](f, 1) = f(0)","proof":[]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) = partial[A](f, 0.suc)","proof":[]}
{"goal":"p(0)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) != partial[A](f, 0.suc) or p(0)"]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) = sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc)))","proof":["sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc)"]}
{"goal":"k.suc.range = k.range.append(k)","proof":["k.suc != k.suc or k.range.append(k) = k.suc.range"]}
{"goal":"map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc)) = map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc))","proof":["k.range.append(k) != k.suc.range"]}
{"goal":"map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc)) = map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(compose[Nat, Nat, A](f, Nat.suc)(k))","proof":["map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(compose[Nat, Nat, A](f, Nat.suc, k)) = map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc))"]}
{"goal":"compose[Nat, Nat, A](f, Nat.suc)(k) = f(k.suc)","proof":["compose[Nat, Nat, A](f, Nat.suc, k) = f(k.suc)"]}
{"goal":"map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc)) = map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(f(k.suc))","proof":["map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(compose[Nat, Nat, A](f, Nat.suc, k)) != map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc))"]}
{"goal":"sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(f(k.suc))) = sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) + f(k.suc)","proof":["sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(f(k.suc))) = sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) + f(k.suc)"]}
{"goal":"sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k)","proof":["sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k)"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)","proof":[]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)","proof":["partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc) != sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc)))"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) = f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc))","proof":["partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc) != partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc)"]}
{"goal":"f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc) = f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc))"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) = partial[A](f, k.suc)","proof":["not p(k) or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) = partial[A](f, k.suc)"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc) = partial[A](f, k.suc) + f(k.suc)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) != partial[A](f, k.suc)"]}
{"goal":"partial[A](f, k.suc.suc) = sum[A](map[Nat, A](k.suc.suc.range, f))","proof":["sum[A](map[Nat, A](k.suc.suc.range, f)) = partial[A](f, k.suc.suc)"]}
{"goal":"k.suc.suc.range = k.suc.range.append(k.suc)","proof":["k.suc.suc != k.suc.suc or k.suc.range.append(k.suc) = k.suc.suc.range"]}
{"goal":"sum[A](map[Nat, A](k.suc.suc.range, f)) = sum[A](map[Nat, A](k.suc.range.append(k.suc), f))","proof":[]}
{"goal":"map[Nat, A](k.suc.range.append(k.suc), f) = map[Nat, A](k.suc.range, f).append(f(k.suc))","proof":["map[Nat, A](k.suc.range, f).append(f(k.suc)) = map[Nat, A](k.suc.range.append(k.suc), f)"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, f).append(f(k.suc))) = sum[A](map[Nat, A](k.suc.range, f)) + f(k.suc)","proof":["sum[A](map[Nat, A](k.suc.range, f).append(f(k.suc))) = sum[A](map[Nat, A](k.suc.range, f)) + f(k.suc)"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, f)) = partial[A](f, k.suc)","proof":["sum[A](map[Nat, A](k.suc.range, f)) = partial[A](f, k.suc)"]}
{"goal":"sum[A](map[Nat, A](k.suc.suc.range, f)) = partial[A](f, k.suc) + f(k.suc)","proof":[]}
{"goal":"partial[A](f, k.suc.suc) = partial[A](f, k.suc) + f(k.suc)","proof":["partial[A](f, k.suc) + f(k.suc) != sum[A](map[Nat, A](k.suc.suc.range, f))"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) = partial[A](f, k.suc.suc)","proof":[]}
{"goal":"p(k.suc)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) != partial[A](f, k.suc.suc) or p(k.suc)"]}
{"goal":"p(n)","proof":["let s0: Nat -> Bool -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p).suc)","not p(s0(p).suc) or not p(0) or p(n)","not p(s0(p).suc)","not p(0) or p(s0(p)) or p(n)","not p(s0(p))","p(s0(p))"]}
{"goal":"partial_shift_suc","proof":["not p(n) or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n) = partial[A](f, n.suc)"]}
{"goal":"partial[A](f, n.suc) = sum[A](map[Nat, A](n.suc.range, f))","proof":["sum[A](map[Nat, A](n.suc.range, f)) = partial[A](f, n.suc)"]}
{"goal":"n.suc.range = n.range.append(n)","proof":["n.suc != n.suc or n.range.append(n) = n.suc.range"]}
{"goal":"map[Nat, A](n.suc.range, f) = map[Nat, A](n.range.append(n), f)","proof":["n.range.append(n) != n.suc.range"]}
{"goal":"map[Nat, A](n.range.append(n), f) = map[Nat, A](n.range, f).append(f(n))","proof":["map[Nat, A](n.range, f).append(f(n)) = map[Nat, A](n.range.append(n), f)"]}
{"goal":"sum[A](map[Nat, A](n.range, f).append(f(n))) = sum[A](map[Nat, A](n.range, f)) + f(n)","proof":["sum[A](map[Nat, A](n.range, f).append(f(n))) = sum[A](map[Nat, A](n.range, f)) + f(n)"]}
{"goal":"sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)","proof":["sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)"]}
{"goal":"sum[A](map[Nat, A](n.suc.range, f)) = partial[A](f, n) + f(n)","proof":[]}
{"goal":"partial_split_last","proof":["sum[A](map[Nat, A](n.suc.range, f)) != partial[A](f, n) + f(n)"]}
{"goal":"partial[A](f, 0) = sum[A](map[Nat, A](0.range, f))","proof":["sum[A](map[Nat, A](0.range, f)) = partial[A](f, 0)"]}
{"goal":"0.range = List.nil[Nat]","proof":["0 != 0 or 0.range = List.nil[Nat]"]}
{"goal":"map[Nat, A](List.nil[Nat], f) = List.nil[A]","proof":["List.nil[Nat].map(f) = map[Nat, A](List.nil[Nat], f)","List.nil[Nat].map(f) != List.nil[A]","List.nil[Nat] != List.nil[Nat] or List.nil[Nat].map(f) = List.nil[A]"]}
{"goal":"sum[A](List.nil[A]) = A.0","proof":["List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0"]}
{"goal":"partial[A](f, 0) = A.0","proof":[]}
{"goal":"partial[A](g, 0) = sum[A](map[Nat, A](0.range, g))","proof":["sum[A](map[Nat, A](0.range, g)) = partial[A](g, 0)"]}
{"goal":"map[Nat, A](List.nil[Nat], g) = List.nil[A]","proof":["List.nil[Nat].map(g) = map[Nat, A](List.nil[Nat], g)","List.nil[Nat].map(g) != List.nil[A]","List.nil[Nat] != List.nil[Nat] or List.nil[Nat].map(g) = List.nil[A]"]}
{"goal":"sum[A](List.nil[A]) = A.0","proof":[]}
{"goal":"partial[A](g, 0) = A.0","proof":[]}
{"goal":"partial[A](f, 0) = partial[A](g, 0)","proof":["partial[A](f, 0) != A.0"]}
{"goal":"p(0)","proof":["partial[A](g, 0) != partial[A](f, 0) or p(0)"]}
{"goal":"k < m.suc","proof":["not k < m or k < m.suc"]}
{"goal":"f(k) = g(k)","proof":["not k < m.suc or g(k) = f(k)"]}
{"goal":"partial[A](f, m) = partial[A](g, m)","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { not p(x0) or s0(x0) < x0 or partial[A](g, x0) = partial[A](f, x0) } and forall(x1: Nat) { g(s0(x1)) != f(s0(x1)) or not p(x1) or partial[A](g, x1) = partial[A](f, x1) } and forall(x2: Nat, x3: Nat) { not x2 < x3 or p(x3) or g(x2) = f(x2) } and forall(x4: Nat) { partial[A](g, x4) != partial[A](f, x4) or p(x4) } }","not s0(m) < m or g(s0(m)) = f(s0(m))","not p(m) or s0(m) < m or partial[A](g, m) = partial[A](f, m)","g(s0(m)) != f(s0(m)) or not p(m) or partial[A](g, m) = partial[A](f, m)","s0(m) < m","g(s0(m)) != f(s0(m))","g(s0(m)) = f(s0(m))"]}
{"goal":"m < m.suc","proof":["not m ∈ m.suc.range or not m >= m.suc","m.suc <= m = m >= m.suc","m.suc <= m or m < m.suc","m.suc <= m","m >= m.suc","m ∈ m.suc.range"]}
{"goal":"f(m) = g(m)","proof":["not m < m.suc or g(m) = f(m)"]}
{"goal":"partial[A](f, m.suc) = partial[A](f, m) + f(m)","proof":["partial[A](f, m) + f(m) = partial[A](f, m.suc)"]}
{"goal":"partial[A](g, m.suc) = partial[A](g, m) + g(m)","proof":["partial[A](g, m) + g(m) = partial[A](g, m.suc)"]}
{"goal":"partial[A](f, m.suc) = partial[A](g, m) + f(m)","proof":["partial[A](f, m) + f(m) != partial[A](f, m.suc)"]}
{"goal":"partial[A](g, m) + f(m) = partial[A](g, m) + g(m)","proof":["g(m) != f(m)"]}
{"goal":"partial[A](f, m.suc) = partial[A](g, m.suc)","proof":[]}
{"goal":"p(m.suc)","proof":["let s0: Nat satisfy { s0 < m.suc or partial[A](g, m.suc) = partial[A](f, m.suc) and (g(s0) != f(s0) or partial[A](g, m.suc) = partial[A](f, m.suc)) }","partial[A](g, m.suc) != partial[A](f, m.suc) or p(m.suc)","not s0 < m.suc or p(m.suc) or g(s0) = f(s0)","partial[A](g, m.suc) != partial[A](f, m.suc)","s0 < m.suc","g(s0) != f(s0)","g(s0) = f(s0)"]}
{"goal":"p(n)","proof":["let s0: Nat -> Bool -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p).suc)","not p(s0(p).suc) or not p(0) or p(n)","not p(s0(p).suc)","not p(0) or p(s0(p)) or p(n)","not p(s0(p))","p(s0(p))"]}
{"goal":"partial_pointwise_eq","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { not p(x0) or s0(x0) < x0 or partial[A](g, x0) = partial[A](f, x0) } and forall(x1: Nat) { g(s0(x1)) != f(s0(x1)) or not p(x1) or partial[A](g, x1) = partial[A](f, x1) } and forall(x2: Nat, x3: Nat) { not x2 < x3 or p(x3) or g(x2) = f(x2) } and forall(x4: Nat) { partial[A](g, x4) != partial[A](f, x4) or p(x4) } }","not s0(n) < n or g(s0(n)) = f(s0(n))","not p(n) or s0(n) < n or partial[A](g, n) = partial[A](f, n)","g(s0(n)) != f(s0(n)) or not p(n) or partial[A](g, n) = partial[A](f, n)","s0(n) < n","g(s0(n)) != f(s0(n))","g(s0(n)) = f(s0(n))"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(n).suc != n","n > n = n < n","not n < n or not n < n","s0(n).suc = n or 0 = n","0 = n","n > n","n < n"]}
{"goal":"n_pred + 1 = n","proof":["n_pred + 1 = 1 + n_pred","1 + n_pred != n","1 + n_pred = n_pred.suc"]}
{"goal":"n - 1 = n_pred","proof":["n_pred + 1 != n or n - 1 = n_pred"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n_pred) = partial[A](f, n_pred.suc)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n_pred) = partial[A](f, n_pred.suc)"]}
{"goal":"partial[A](f, n_pred.suc) = partial[A](f, n)","proof":["n_pred.suc != n"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n_pred) = partial[A](f, n)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n_pred) != partial[A](f, n_pred.suc)"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1) = partial[A](f, n)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n_pred) != partial[A](f, n)"]}
{"goal":"partial_drop_first","proof":[]}
{"goal":"n > 0","proof":["not n <= 0 or not 2 < n or 2 < 0","0 < n or n < 0 or 0 = n","n < 2 or 2 < n or 2 = n","2 <= n = n >= 2","n > 0 = 0 < n","not 0 < n","not 2 <= n or not n < 2","n <= 0 or 0 < n","n <= 0","n < 0 or 0 = n","not 2 < 0","not n < 0","0 = n","2 != n","2 <= n","not 2 < n","not n < 2","n < 2"]}
{"goal":"partial[A](f, n) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1)","proof":["not n > 0 or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1) = partial[A](f, n)"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(n).suc != n","n > n = n < n","not n < n or not n < n","s0(n).suc = n or 0 = n","0 = n","n > n","n < n"]}
{"goal":"n_minus_1 + 1 = n","proof":["n_minus_1 + 1 = 1 + n_minus_1","1 + n_minus_1 != n","1 + n_minus_1 = n_minus_1.suc"]}
{"goal":"n - 1 = n_minus_1","proof":["n_minus_1 + 1 != n or n - 1 = n_minus_1"]}
{"goal":"n_minus_1.suc >= 2","proof":["not n >= 2"]}
{"goal":"n_minus_1 >= 1","proof":["not 1.suc <= n_minus_1.suc or 1 <= n_minus_1","1 <= n_minus_1 = n_minus_1 >= 1","2 <= n_minus_1.suc = n_minus_1.suc >= 2","not 1 <= n_minus_1","2 <= n_minus_1.suc","not 1.suc <= n_minus_1.suc","1.suc <= n_minus_1.suc"]}
{"goal":"exists(k0: Nat) { k0.suc = n_minus_1 }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(n_minus_1).suc != n_minus_1","not 0 ∈ 0.suc.range or not 0 >= 0.suc","s0(n_minus_1).suc = n_minus_1 or n_minus_1 = 0","n_minus_1 = 0","0 ∈ 0.suc.range","n_minus_1 >= 0.suc","0 >= 0.suc"]}
{"goal":"n_minus_2 + 1 = n_minus_1","proof":["n_minus_2.suc + 1 = (n_minus_2 + 1).suc","(n_minus_2 + 1).suc != n_minus_1.suc or n_minus_2 + 1 = n_minus_1","(n_minus_2 + 1).suc != n_minus_1.suc"]}
{"goal":"n_minus_1 - 1 = n_minus_2","proof":["n_minus_2 + 1 != n_minus_1 or n_minus_1 - 1 = n_minus_2"]}
{"goal":"n - 2 = n_minus_2","proof":["n_minus_2 + 2 != n or n - 2 = n_minus_2","n_minus_2 + 2 != n","n_minus_2 + 1.suc = (n_minus_2 + 1).suc","1 + 1 = 1.suc"]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_1) = partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2.suc)","proof":["n_minus_2.suc != n_minus_1"]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2.suc) = partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2) + compose[Nat, Nat, A](f, Nat.suc)(n_minus_2)","proof":["partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2) + compose[Nat, Nat, A](f, Nat.suc, n_minus_2) = partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2.suc)"]}
{"goal":"compose[Nat, Nat, A](f, Nat.suc)(n_minus_2) = f(n_minus_2.suc)","proof":["compose[Nat, Nat, A](f, Nat.suc, n_minus_2) = f(n_minus_2.suc)"]}
{"goal":"n_minus_2.suc = n_minus_1","proof":[]}
{"goal":"n_minus_1 = n - 1","proof":[]}
{"goal":"compose[Nat, Nat, A](f, Nat.suc)(n_minus_2) = f(n_minus_1)","proof":["compose[Nat, Nat, A](f, Nat.suc, n_minus_2) != f(n_minus_2.suc)"]}
{"goal":"f(n_minus_1) = f(n - 1)","proof":["n - 1 != n_minus_1"]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_1) = partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2) + f(n - 1)","proof":[]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1) = partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_1)","proof":["n - 1 != n_minus_1"]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1) = partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2) + f(n - 1)","proof":["partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2) + f(n - 1) != partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_1)"]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) = partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2)","proof":["n - 2 != n_minus_2"]}
{"goal":"partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1) = partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)","proof":["partial[A](compose[Nat, Nat, A](f, Nat.suc), n_minus_2) + f(n - 1) != partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1)"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1) = f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1))","proof":["partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1) != partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1)"]}
{"goal":"f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1) = f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1))"]}
{"goal":"f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)","proof":[]}
{"goal":"partial[A](f, n) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)","proof":[]}
{"goal":"partial_split_first_last","proof":[]}
{"goal":"p(List.nil[T])","proof":["map[T, U](List.nil[T], f).length != List.nil[T].length or p(List.nil[T])","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","map[T, U](List.nil[T], f).length != List.nil[T].length","List.nil[T] != List.nil[T] or List.nil[T].length = 0","List.nil[U] != List.nil[U] or List.nil[U].length = 0","List.nil[U].length = 0","List.nil[T].length = 0","map[T, U](List.nil[T], f).length != 0","map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"map[T, U](List.cons(head, tail), f).length = List.cons(head, tail).length","proof":["not p(tail) or map[T, U](tail, f).length = tail.length","List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or List.cons(f(head), map[T, U](tail, f)).length = map[T, U](tail, f).length.suc","List.cons(f(head), map[T, U](tail, f)).length = map[T, U](tail, f).length.suc","List.cons(head, tail).length = tail.length.suc","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","map[T, U](tail, f).length = tail.length"]}
{"goal":"p(list)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","map[T, U](List.cons(s0(p), s1(p)), f).length != List.cons(s0(p), s1(p)).length or p(List.cons(s0(p), s1(p)))","not p(s1(p)) or map[T, U](List.cons(s0(p), s1(p)), f).length = List.cons(s0(p), s1(p)).length","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p)))","map[T, U](List.cons(s0(p), s1(p)), f).length = List.cons(s0(p), s1(p)).length"]}
{"goal":"map_length","proof":["not p(list) or map[T, U](list, f).length = list.length"]}
{"goal":"p(List.nil[T])","proof":["item ∈ map[T, U](List.nil[T], f) or p(List.nil[T])","item ∈ map[T, U](List.nil[T], f)","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","not item ∈ List.nil[U] or List.nil[U] != List.nil[U]","not item ∈ List.nil[U]","map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"p(List.cons(head, tail))","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { not item ∈ map[T, U](x0, f) or not p(x0) or s0(x0) ∈ x0 } and forall(x1: List[T]) { not item ∈ map[T, U](x1, f) or not p(x1) or f(s0(x1)) = item } and forall(x2: List[T]) { item ∈ map[T, U](x2, f) or p(x2) } and forall(x3: List[T], x4: T) { not x4 ∈ x3 or item != f(x4) or p(x3) } }","not s0(tail) ∈ List.cons(head, tail) or f(s0(tail)) != item or p(List.cons(head, tail))","not item ∈ map[T, U](tail, f) or not p(tail) or f(s0(tail)) = item","not item ∈ map[T, U](tail, f) or not p(tail) or s0(tail) ∈ tail","not s0(tail) ∈ tail or List.cons(head, tail) != List.cons(head, tail) or s0(tail) ∈ List.cons(head, tail) or s0(tail) = head","List.cons(head, tail) != List.cons(head, tail) or s0(tail) != head or s0(tail) ∈ List.cons(head, tail)","not s0(tail) ∈ List.cons(head, tail) or f(s0(tail)) != item","s0(tail) ∈ tail","f(s0(tail)) = item","s0(tail) != head or s0(tail) ∈ List.cons(head, tail)","not s0(tail) ∈ tail or s0(tail) ∈ List.cons(head, tail) or s0(tail) = head","not s0(tail) ∈ List.cons(head, tail)","s0(tail) != head","s0(tail) = head"]}
{"goal":"f(head) = item","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","not item ∈ List.cons(f(head), map[T, U](tail, f)) or List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or item ∈ map[T, U](tail, f) or f(head) = item","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or not item ∈ List.cons(f(head), map[T, U](tail, f)) or item ∈ map[T, U](tail, f)","not item ∈ List.cons(f(head), map[T, U](tail, f)) or item ∈ map[T, U](tail, f)","item ∈ List.cons(f(head), map[T, U](tail, f))","not item ∈ List.cons(f(head), map[T, U](tail, f))"]}
{"goal":"exists(k0: T) { k0 = head and List.cons(head, tail).contains(k0) }","proof":["not head ∈ List.cons(head, tail) or head != head","not head ∈ List.cons(head, tail)","List.cons(head, tail) != List.cons(head, tail) or head != head or head ∈ List.cons(head, tail)","List.cons(head, tail) != List.cons(head, tail) or head ∈ List.cons(head, tail)","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"p(List.cons(head, tail))","proof":["let s0: T satisfy { s0 = head and s0 ∈ List.cons(head, tail) }","not s0 ∈ List.cons(head, tail) or f(s0) != item or p(List.cons(head, tail))","f(s0) = item","f(s0) != item"]}
{"goal":"p(List.cons(head, tail))","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["item ∈ map[T, U](List.cons(head, tail), f) or p(List.cons(head, tail))"]}
{"goal":"map_contains","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { not item ∈ map[T, U](x0, f) or not p(x0) or s0(x0) ∈ x0 } and forall(x1: List[T]) { not item ∈ map[T, U](x1, f) or not p(x1) or f(s0(x1)) = item } and forall(x2: List[T]) { item ∈ map[T, U](x2, f) or p(x2) } and forall(x3: List[T], x4: T) { not x4 ∈ x3 or item != f(x4) or p(x3) } }","not s0(list) ∈ list or f(s0(list)) != item","let (s1: T, s2: List[T]) satisfy { forall(x5: List[T]) { not p(List.nil[T]) or p(s2) or p(x5) } and forall(x6: List[T]) { not p(List.cons(s1, s2)) or not p(List.nil[T]) or p(x6) } }","not p(List.nil[T]) or p(s2) or p(s2)","p(s2) or p(s2)","not p(List.cons(s1, s2)) or not p(List.nil[T]) or p(list)","not p(List.cons(s1, s2)) or p(list)","not p(s2) or p(List.cons(s1, s2))","not item ∈ map[T, U](list, f) or not p(list) or f(s0(list)) = item","not item ∈ map[T, U](list, f) or not p(list) or s0(list) ∈ list","p(s2)","p(List.cons(s1, s2))","p(list)","s0(list) ∈ list","f(s0(list)) = item","f(s0(list)) != item"]}
{"goal":"p(List.nil[T])","proof":["not map[T, U](List.nil[T], f).is_unique or p(List.nil[T])","not map[T, U](List.nil[T], f).is_unique","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","List.nil[U].unique != List.nil[U] or List.nil[U].is_unique","List.nil[U] != List.nil[U] or List.nil[U].unique = List.nil[U]","List.nil[U].unique = List.nil[U]","map[T, U](List.nil[T], f) = List.nil[U]","not List.nil[U].is_unique"]}
{"goal":"not tail_map.is_unique","proof":["let s0: List[U] -> U satisfy { forall(x0: List[U]) { not has_duplicate(x0) or x0.count(s0(x0)) > 1 } and forall(x1: List[U], x2: U) { not x1.count(x2) > 1 or has_duplicate(x1) } }","not has_duplicate(tail_map) or tail_map.count(s0(tail_map)) > 1","not tail_map.is_unique or tail_map.count(s0(tail_map)) <= 1","tail_map.count(s0(tail_map)) <= 1","tail_map.count(s0(tail_map)) > 1 = 1 < tail_map.count(s0(tail_map))","not tail_map.count(s0(tail_map)) <= 1 or not 1 < tail_map.count(s0(tail_map))","tail_map.count(s0(tail_map)) > 1","1 < tail_map.count(s0(tail_map))"]}
{"goal":"not map[T, U](tail, f).is_unique","proof":[]}
{"goal":"exists(k0: T) { tail.count(k0) > 1 }","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { x0.count(s0(x0)) > 1 or x0.is_unique } }","not tail.count(s0(tail)) > 1","tail.count(s0(tail)) > 1 or tail.is_unique"]}
{"goal":"List.cons(head, tail).count(x) >= tail.count(x)","proof":["not List.cons(head, tail).is_unique or tail.is_unique"]}
{"goal":"not List.cons(head, tail).is_unique","proof":["not List.cons(head, tail).is_unique or tail.is_unique"]}
{"goal":"false","proof":[]}
{"goal":"tail.is_unique","proof":[]}
{"goal":"exists(k0: T, k1: T) { k0 != k1 and f(k0) = f(k1) }","proof":["let (s0: List[T] -> T, s1: List[T] -> T) satisfy { forall(x0: List[T]) { s1(x0) != s0(x0) or not x0.is_unique or not p(x0) or map[T, U](x0, f).is_unique } and forall(x1: List[T]) { not x1.is_unique or not p(x1) or map[T, U](x1, f).is_unique or f(s1(x1)) = f(s0(x1)) } and forall(x2: List[T]) { x2.is_unique or p(x2) } and forall(x3: List[T]) { not map[T, U](x3, f).is_unique or p(x3) } and forall(x4: T, x5: T, x6: List[T]) { f(x4) != f(x5) or p(x6) or x4 = x5 } }","f(s1(tail)) != f(s0(tail)) or s1(tail) = s0(tail)","s1(tail) != s0(tail) or not tail.is_unique or not p(tail) or map[T, U](tail, f).is_unique","not tail.is_unique or not p(tail) or map[T, U](tail, f).is_unique or f(s1(tail)) = f(s0(tail))","s1(tail) != s0(tail)","f(s1(tail)) = f(s0(tail))","f(s1(tail)) != f(s0(tail))"]}
{"goal":"p(List.cons(head, tail))","proof":["f(b) != f(a) or p(List.cons(head, tail)) or b = a","f(b) != f(a) or b = a"]}
{"goal":"tail_map.is_unique","proof":["let s0: List[U] -> U satisfy { forall(x0: List[U]) { x0.count(s0(x0)) > 1 or x0.is_unique } }","not tail_map.count(s0(tail_map)) > 1 or has_duplicate(tail_map)","tail_map.count(s0(tail_map)) > 1 or tail_map.is_unique","tail_map.count(s0(tail_map)) > 1"]}
{"goal":"tail_map.contains(dup)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(dup, tail_map) != List.cons(dup, tail_map) or List.cons(dup, tail_map).unique = List.cons(dup, tail_map.unique) or dup ∈ tail_map","List.cons(dup, tail_map).unique != List.cons(dup, tail_map) or List.cons(dup, tail_map).is_unique","not tail_map.is_unique or tail_map.unique = tail_map","tail_map.unique = tail_map","List.cons(dup, tail_map) != List.cons(dup, tail_map) or List.cons(dup, tail_map).unique = List.cons(dup, tail_map.unique)","List.cons(dup, tail_map).unique = List.cons(dup, tail_map.unique)","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(dup, tail_map).unique = List.cons(dup, tail_map)","not List.cons(f(head), map[T, U](tail, f)).is_unique","not List.cons(f(head), tail_map).is_unique","List.cons(dup, tail_map).is_unique","not List.cons(dup, tail_map).is_unique"]}
{"goal":"tail_map.count(dup) = 1","proof":["not dup ∈ tail_map or tail_map.count(dup) >= 1","not tail_map.count(dup) <= 1 or not 1 <= tail_map.count(dup) or tail_map.count(dup) = 1","not tail_map.is_unique or tail_map.count(dup) <= 1","1 <= tail_map.count(dup) = tail_map.count(dup) >= 1","tail_map.count(dup) <= 1","not 1 <= tail_map.count(dup)","tail_map.count(dup) >= 1","not tail_map.count(dup) >= 1"]}
{"goal":"not tail.contains(head)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","not dup ∈ tail_map or List.cons(dup, tail_map) != List.cons(dup, tail_map) or List.cons(dup, tail_map).unique = tail_map.unique","not head ∈ tail or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).unique = tail.unique","not List.cons(head, tail).is_unique or tail.is_unique","tail.is_unique","map[T, U](List.cons(head, tail), f).unique != map[T, U](List.cons(head, tail), f) or map[T, U](List.cons(head, tail), f).is_unique","not tail_map.is_unique or tail_map.unique = tail_map","not List.cons(head, tail).is_unique or List.cons(head, tail).unique = List.cons(head, tail)","not tail.is_unique or tail.unique = tail","tail_map.unique = tail_map","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).unique = tail.unique","List.cons(head, tail).unique = tail.unique","not dup ∈ tail_map or List.cons(dup, tail_map).unique = tail_map.unique","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(head, tail).unique = List.cons(head, tail)","List.cons(dup, tail_map).unique = tail_map.unique","map[T, U](List.cons(head, tail), f).unique != map[T, U](List.cons(head, tail), f)","tail.unique = tail"]}
{"goal":"exists(k0: T) { tail.contains(k0) and f(k0) = dup }","proof":["let s0: (List[T], T -> U, U) -> T satisfy { forall(x0: List[T], x1: T -> U, x2: U) { not x2 ∈ map[T, U](x0, x1) or s0(x0, x1, x2) ∈ x0 } and forall(x3: List[T], x4: T -> U, x5: U) { not x5 ∈ map[T, U](x3, x4) or x4(s0(x3, x4, x5)) = x5 } }","not s0(tail, f, dup) ∈ tail or f(s0(tail, f, dup)) != dup","not dup ∈ map[T, U](tail, f) or f(s0(tail, f, dup)) = dup","not dup ∈ map[T, U](tail, f) or s0(tail, f, dup) ∈ tail","dup ∈ map[T, U](tail, f)","s0(tail, f, dup) ∈ tail","f(s0(tail, f, dup)) = dup","f(s0(tail, f, dup)) != dup"]}
{"goal":"map[T, U](List.cons(head, tail), f).count(dup) = 1 + tail_map.count(dup)","proof":["map[T, U](List.cons(head, tail), f) != List.cons(dup, tail_map) or dup != dup or map[T, U](List.cons(head, tail), f).count(dup) = 1 + tail_map.count(dup)","List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","map[T, U](List.cons(head, tail), f) != List.cons(dup, tail_map) or dup != dup","map[T, U](List.cons(head, tail), f) != List.cons(dup, tail_map)","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"map[T, U](List.cons(head, tail), f).count(dup) > 1","proof":["not 1 + tail_map.count(dup) > 1","not 1 + 1 > 1","1.suc > 1 = 1 < 1.suc","1 + 1 = 1.suc","not 1.suc > 1","not 1 < 1.suc","1 < 1.suc"]}
{"goal":"f(head) = f(x)","proof":["f(head) != dup"]}
{"goal":"head != x","proof":["head ∈ tail"]}
{"goal":"p(List.cons(head, tail))","proof":["f(x) != f(head) or p(List.cons(head, tail)) or x = head","f(x) != f(head) or x = head"]}
{"goal":"p(List.cons(head, tail))","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).is_unique or p(List.cons(head, tail))","not map[T, U](List.cons(head, tail), f).is_unique or p(List.cons(head, tail))","List.cons(head, tail).is_unique","not map[T, U](List.cons(head, tail), f).is_unique","map[T, U](List.cons(head, tail), f).is_unique"]}
{"goal":"pigeonhole_unique_map","proof":["let (s0: List[T] -> T, s1: List[T] -> T) satisfy { forall(x0: List[T]) { s1(x0) != s0(x0) or not x0.is_unique or not p(x0) or map[T, U](x0, f).is_unique } and forall(x1: List[T]) { not x1.is_unique or not p(x1) or map[T, U](x1, f).is_unique or f(s1(x1)) = f(s0(x1)) } and forall(x2: List[T]) { x2.is_unique or p(x2) } and forall(x3: List[T]) { not map[T, U](x3, f).is_unique or p(x3) } and forall(x4: T, x5: T, x6: List[T]) { f(x4) != f(x5) or p(x6) or x4 = x5 } }","f(s1(items)) != f(s0(items)) or s1(items) = s0(items)","let (s2: List[T] -> Bool -> T, s3: List[T] -> Bool -> List[T]) satisfy { forall(x7: List[T] -> Bool, x8: List[T]) { not x7(List.nil[T]) or x7(s3(x7)) or x7(x8) } and forall(x9: List[T] -> Bool, x10: List[T]) { not x9(List.cons(s2(x9), s3(x9))) or not x9(List.nil[T]) or x9(x10) } }","not p(s3(p)) or p(List.cons(s2(p), s3(p)))","s1(items) != s0(items) or not items.is_unique or not p(items) or map[T, U](items, f).is_unique","not items.is_unique or not p(items) or map[T, U](items, f).is_unique or f(s1(items)) = f(s0(items))","not p(List.cons(s2(p), s3(p))) or not p(List.nil[T]) or p(items)","not p(List.nil[T]) or p(s3(p)) or p(s3(p))","p(s3(p)) or p(s3(p))","p(s3(p))","s1(items) != s0(items) or not p(items)","not p(List.cons(s2(p), s3(p))) or p(items)","not p(items) or f(s1(items)) = f(s0(items))","p(List.cons(s2(p), s3(p)))","p(items)","s1(items) != s0(items)","f(s1(items)) = f(s0(items))","f(s1(items)) != f(s0(items))"]}
{"goal":"items.length = map[T, U](items, f).length","proof":["map[T, U](items, f).length = items.length"]}
{"goal":"map[T, U](items, f).unique.length < map[T, U](items, f).length","proof":["not map[T, U](items, f).unique.length < items.length","items.length > map[T, U](items, f).unique.length = map[T, U](items, f).unique.length < items.length"]}
{"goal":"not map[T, U](items, f).is_unique","proof":["not map[T, U](items, f).is_unique or map[T, U](items, f).unique = map[T, U](items, f)","not map[T, U](items, f).length < map[T, U](items, f).length","map[T, U](items, f).unique = map[T, U](items, f)"]}
{"goal":"pigeonhole_map","proof":["let (s0: (List[T], T -> U) -> T, s1: (List[T], T -> U) -> T) satisfy { forall(x0: List[T], x1: T -> U) { s1(x0, x1) != s0(x0, x1) or not x0.is_unique or map[T, U](x0, x1).is_unique } and forall(x2: List[T], x3: T -> U) { not x2.is_unique or map[T, U](x2, x3).is_unique or x3(s1(x2, x3)) = x3(s0(x2, x3)) } }","f(s1(items, f)) != f(s0(items, f)) or s1(items, f) = s0(items, f)","not items.is_unique or map[T, U](items, f).is_unique or f(s1(items, f)) = f(s0(items, f))","s1(items, f) != s0(items, f) or not items.is_unique or map[T, U](items, f).is_unique","s1(items, f) != s0(items, f)","f(s1(items, f)) = f(s0(items, f))","f(s1(items, f)) != f(s0(items, f))"]}
{"goal":"tail_cancels_cons","proof":["List.cons(a, b) != List.cons(a, b) or List.cons(a, b).tail = b","List.cons(a, b) != List.cons(a, b)"]}
{"goal":"drop_zero","proof":["0 != 0 or a.drop(0) = a"]}
{"goal":"drop_one","proof":["0.suc != 1 or a.tail.drop(0) = a.drop(1)","a.tail.drop(0) = a.tail","a.tail.drop(0) != a.drop(1)"]}
{"goal":"(List.nil[T] + b).drop(List.nil[T].length) = b.drop(0)","proof":["List.nil[T] != List.nil[T] or List.nil[T].length = 0","List.nil[T] + b = b","b.drop(List.nil[T].length) != b.drop(0)","List.nil[T].length = 0","List.nil[T].length != 0"]}
{"goal":"b.drop(0) = b","proof":["0 != 0 or b.drop(0) = b"]}
{"goal":"p(List.nil[T])","proof":["(List.nil[T] + b).drop(List.nil[T].length) != b or p(List.nil[T])","(List.nil[T] + b).drop(List.nil[T].length) = b","(List.nil[T] + b).drop(List.nil[T].length) != b"]}
{"goal":"(List.cons(head, tail) + b).drop(List.cons(head, tail).length) = List.cons(head, tail + b).drop(tail.length.suc)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + b = List.cons(head, tail + b)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail).length = tail.length.suc","(List.cons(head, tail) + b).drop(tail.length.suc) != List.cons(head, tail + b).drop(tail.length.suc)","List.cons(head, tail) + b != List.cons(head, tail + b)"]}
{"goal":"List.cons(head, tail + b).drop(tail.length.suc) = (tail + b).drop(tail.length)","proof":["tail.length.suc != tail.length.suc or List.cons(head, tail + b).tail.drop(tail.length) = List.cons(head, tail + b).drop(tail.length.suc)","List.cons(head, tail + b).tail = tail + b","List.cons(head, tail + b).tail.drop(tail.length) = List.cons(head, tail + b).drop(tail.length.suc)","List.cons(head, tail + b).tail.drop(tail.length) != List.cons(head, tail + b).drop(tail.length.suc)"]}
{"goal":"(tail + b).drop(tail.length) = b","proof":["not p(tail) or (tail + b).drop(tail.length) = b"]}
{"goal":"p(List.cons(head, tail))","proof":["(List.cons(head, tail) + b).drop(List.cons(head, tail).length) != b or p(List.cons(head, tail))","List.cons(head, tail + b).drop(tail.length.suc) = b","(List.cons(head, tail) + b).drop(List.cons(head, tail).length) != b","(List.cons(head, tail) + b).drop(List.cons(head, tail).length) = b"]}
{"goal":"drop_cancels_add","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(a) or (a + b).drop(a.length) = b","not p(a)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)","p(s1(p)) or p(a)","p(s1(p))","not p(List.cons(s0(p), s1(p))) or p(a)","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"l.drop(0) = l","proof":["0 != 0 or l.drop(0) = l"]}
{"goal":"l.drop(0).drop(k) = l.drop(k)","proof":["l.drop(0) != l"]}
{"goal":"0 + k = k","proof":["k + 0 = 0 + k","k + 0 != k","0 != 0 or k + 0 = k"]}
{"goal":"l.drop(0 + k) = l.drop(k)","proof":["0 + k != k"]}
{"goal":"f(0)","proof":["let (s0: Nat -> List[T], s1: Nat -> Nat) satisfy { forall(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0).drop(x2) = x1.drop(x0 + x2) } and forall(x3: Nat) { s0(x3).drop(x3).drop(s1(x3)) != s0(x3).drop(x3 + s1(x3)) or f(x3) } }","s0(0).drop(0 + s1(0)) = s0(0).drop(s1(0))","s0(0).drop(0).drop(s1(0)) != s0(0).drop(0 + s1(0)) or f(0)","s0(0).drop(0) = s0(0)","s0(0).drop(0).drop(s1(0)) != s0(0).drop(0 + s1(0))"]}
{"goal":"l.drop(x.suc).drop(k) = l.tail.drop(x).drop(k)","proof":["l.tail.drop(x) != l.drop(x.suc)","x.suc != x.suc or l.tail.drop(x) = l.drop(x.suc)"]}
{"goal":"f(x)","proof":[]}
{"goal":"l.tail.drop(x).drop(k) = l.tail.drop(x + k)","proof":["not f(x) or l.tail.drop(x).drop(k) = l.tail.drop(x + k)"]}
{"goal":"x.suc + k = (x + k).suc","proof":["x.suc + k = (x + k).suc"]}
{"goal":"l.drop(x.suc + k) = l.drop((x + k).suc)","proof":["x.suc + k != (x + k).suc"]}
{"goal":"l.drop((x + k).suc) = l.tail.drop(x + k)","proof":["(x + k).suc != (x + k).suc or l.tail.drop(x + k) = l.drop((x + k).suc)"]}
{"goal":"l.drop(x.suc).drop(k) = l.drop(x.suc + k)","proof":[]}
{"goal":"f(x.suc)","proof":["let (s0: Nat -> List[T], s1: Nat -> Nat) satisfy { forall(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0).drop(x2) = x1.drop(x0 + x2) } and forall(x3: Nat) { s0(x3).drop(x3).drop(s1(x3)) != s0(x3).drop(x3 + s1(x3)) or f(x3) } }","s0(x.suc).drop(x.suc).drop(s1(x.suc)) = s0(x.suc).drop(x.suc + s1(x.suc))","s0(x.suc).drop(x.suc).drop(s1(x.suc)) != s0(x.suc).drop(x.suc + s1(x.suc)) or f(x.suc)"]}
{"goal":"f(m)","proof":["let s0: Nat satisfy { forall(x0: Nat) { not f(0) or f(s0) or f(x0) } and forall(x1: Nat) { not f(s0.suc) or not f(0) or f(x1) } }","not f(0) or f(s0) or f(m)","f(s0) or f(m)","f(s0)","not f(s0.suc) or not f(0) or f(m)","not f(s0.suc) or f(m)","not f(s0.suc)","not f(s0) or f(s0.suc)"]}
{"goal":"drop_twice","proof":["not f(m) or a.drop(m).drop(n) = a.drop(m + n)"]}
{"goal":"q(List.nil[T])","proof":["List.nil[T].drop_last(0) != List.nil[T] or q(List.nil[T])","List.nil[T].drop_last(0) != List.nil[T]","List.nil[T] != List.nil[T] or List.nil[T].drop_last(0) = List.nil[T]"]}
{"goal":"List.cons(head, tail).drop_last(0) = List.cons(head, tail.drop_last(0))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).drop_last(0) = List.cons(head, tail.drop_last(0)) or tail.length < 0","tail.length < 0","not tail.length < 0"]}
{"goal":"List.cons(head, tail.drop_last(0)) = List.cons(head, tail)","proof":["not q(tail) or tail.drop_last(0) = tail","tail.drop_last(0) != tail","tail.drop_last(0) = tail"]}
{"goal":"q(List.cons(head, tail))","proof":["List.cons(head, tail).drop_last(0) != List.cons(head, tail) or q(List.cons(head, tail))","List.cons(head, tail).drop_last(0) != List.cons(head, tail)","List.cons(head, tail).drop_last(0) = List.cons(head, tail)"]}
{"goal":"q(a)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not q(s1(q)) or q(List.cons(s0(q), s1(q)))","not q(List.cons(s0(q), s1(q))) or not q(List.nil[T]) or q(a)","not q(List.nil[T]) or q(s1(q)) or q(a)","q(s1(q))","not q(List.cons(s0(q), s1(q)))"]}
{"goal":"drop_last_zero","proof":["not q(a) or a.drop_last(0) = a"]}
{"goal":"r(List.nil[T])","proof":["List.nil[T].drop_last(List.nil[T].length) != List.nil[T] or r(List.nil[T])","List.nil[T].drop_last(List.nil[T].length) != List.nil[T]","List.nil[T] != List.nil[T] or List.nil[T].drop_last(List.nil[T].length) = List.nil[T]"]}
{"goal":"List.cons(head, tail).drop_last(List.cons(head, tail).length) = List.cons(head, tail).drop_last(tail.length.suc)","proof":["List.cons(head, tail).length != tail.length.suc","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"List.cons(head, tail).drop_last(tail.length.suc) = List.nil[T]","proof":["not tail.length < tail.length.suc or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).drop_last(tail.length.suc) = List.nil[T]","tail.length < tail.length.suc","not tail.length < tail.length.suc or List.cons(head, tail).drop_last(tail.length.suc) = List.nil[T]"]}
{"goal":"r(List.cons(head, tail))","proof":["List.cons(head, tail).drop_last(List.cons(head, tail).length) != List.nil[T] or r(List.cons(head, tail))","List.cons(head, tail).drop_last(List.cons(head, tail).length) != List.nil[T]","List.cons(head, tail).drop_last(List.cons(head, tail).length) = List.nil[T]"]}
{"goal":"r(l)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not r(s1(r)) or r(List.cons(s0(r), s1(r)))","not r(List.cons(s0(r), s1(r))) or not r(List.nil[T]) or r(l)","not r(List.nil[T]) or r(s1(r)) or r(l)","r(s1(r))","not r(List.cons(s0(r), s1(r)))"]}
{"goal":"drop_last_all","proof":["not r(l) or l.drop_last(l.length) = List.nil[T]"]}
{"goal":"p(List.nil[T])","proof":["(List.nil[T] + b).drop_last(b.length) != List.nil[T] or p(List.nil[T])","List.nil[T] + b = b","(List.nil[T] + b).drop_last(b.length) != List.nil[T]","(List.nil[T] + b).drop_last(b.length) = List.nil[T]"]}
{"goal":"exists(k0: Nat) { b.length + k0 = (tail + b).length }","proof":["let s0: (Nat, Nat) -> Nat satisfy { forall(x0: Nat, x1: Nat) { not x0 <= x1 or x0 + s0(x0, x1) = x1 } and forall(x2: Nat, x3: Nat, x4: Nat) { x2 + x3 != x4 or x2 <= x4 } }","b.length + s0(b.length, (tail + b).length) != (tail + b).length","tail.length + b.length = (tail + b).length","not b.length <= (tail + b).length or b.length + s0(b.length, (tail + b).length) = (tail + b).length","b.length + tail.length != b.length + tail.length or b.length <= b.length + tail.length","tail.length + b.length = b.length + tail.length","not b.length <= (tail + b).length","b.length <= b.length + tail.length","not b.length <= tail.length + b.length"]}
{"goal":"c = tail.length","proof":["tail.length + b.length = (tail + b).length","tail.length + b.length != c + b.length or tail.length = c","b.length + c = c + b.length","(tail + b).length = c + b.length","tail.length + b.length != c + b.length"]}
{"goal":"b.length <= (tail + b).length","proof":["(tail + b).length != b.length + c or b.length <= (tail + b).length"]}
{"goal":"(List.cons(head, tail) + b).drop_last(b.length) = List.cons(head, tail + b).drop_last(b.length)","proof":["List.cons(head, tail) + b != List.cons(head, tail + b)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + b = List.cons(head, tail + b)"]}
{"goal":"List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length))","proof":["List.cons(head, tail + b) != List.cons(head, tail + b) or List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length)) or (tail + b).length < b.length","not b.length <= (tail + b).length or not (tail + b).length < b.length","(tail + b).length < b.length","not (tail + b).length < b.length"]}
{"goal":"p(tail)","proof":[]}
{"goal":"List.cons(head, (tail + b).drop_last(b.length)) = List.cons(head, tail)","proof":["not p(tail) or (tail + b).drop_last(b.length) = tail","(tail + b).drop_last(b.length) != tail","(tail + b).drop_last(b.length) = tail"]}
{"goal":"p(List.cons(head, tail))","proof":["(List.cons(head, tail) + b).drop_last(b.length) != List.cons(head, tail) or p(List.cons(head, tail))","List.cons(head, tail + b).drop_last(b.length) = List.cons(head, tail)","(List.cons(head, tail) + b).drop_last(b.length) != List.cons(head, tail)","(List.cons(head, tail) + b).drop_last(b.length) = List.cons(head, tail)"]}
{"goal":"p(a)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)","p(s1(p))","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"drop_last_cancels_add","proof":["not p(a) or (a + b).drop_last(b.length) = a"]}
{"goal":"zero_until","proof":["n.range.drop(0) = 0.until(n)"]}
{"goal":"n.range.length = n","proof":["n.range.length = n"]}
{"goal":"until_self","proof":["n.range.drop(n) = n.until(n)","n.range + List.nil[Nat] = n.range"]}
{"goal":"n.suc.range = n.range + List.singleton(n)","proof":["n.suc != n.suc or n.range.append(n) = n.suc.range","n.range + List.singleton(n) = n.range.append(n)","n.range.append(n) != n.suc.range"]}
{"goal":"n.range.length = n","proof":["n.range.length = n"]}
{"goal":"until_suc","proof":["n.suc.range.drop(n) = n.until(n.suc)"]}
{"goal":"zero_upto","proof":["0.until(n.suc) = 0.upto(n)","0.until(n.suc) = n.suc.range"]}
{"goal":"upto_self","proof":["n.until(n.suc) = n.upto(n)","n.until(n.suc) = List.singleton(n)"]}
{"goal":"exists(k0: Nat) { a + k0 = b }","proof":["let s0: (Nat, Nat) -> Nat satisfy { forall(x0: Nat, x1: Nat) { not x0 <= x1 or x0 + s0(x0, x1) = x1 } and forall(x2: Nat, x3: Nat, x4: Nat) { x2 + x3 != x4 or x2 <= x4 } }","a + s0(a, b) != b","not a <= b or a + s0(a, b) = b"]}
{"goal":"f(0)","proof":["a.range + a.until(a + 0) != (a + 0).range or f(0)","a.range + List.nil[Nat] = a.range","a + 0 = a","a.range + a.until(a + 0) != (a + 0).range"]}
{"goal":"a.until(a + x.suc) = (a + x.suc).range.drop(a)","proof":["(a + x.suc).range.drop(a) = a.until(a + x.suc)"]}
{"goal":"(a + x.suc).range = (a + x).range + List.singleton(a + x)","proof":["a + x.suc != (a + x).suc or (a + x).range.append(a + x) = (a + x.suc).range","a + x.suc = (a + x).suc","(a + x).range + List.singleton(a + x) = (a + x).range.append(a + x)","(a + x).range.append(a + x) != (a + x.suc).range"]}
{"goal":"a.until(a + x.suc) = ((a + x).range + List.singleton(a + x)).drop(a)","proof":[]}
{"goal":"f(x)","proof":[]}
{"goal":"(a + x).range = a.range + a.until(a + x)","proof":["not f(x) or a.range + a.until(a + x) = (a + x).range"]}
{"goal":"a.until(a + x.suc) = (a.range + a.until(a + x) + List.singleton(a + x)).drop(a)","proof":["((a + x).range + List.singleton(a + x)).drop(a) != a.until(a + x.suc)"]}
{"goal":"a.range.length = a","proof":["a.range.length = a"]}
{"goal":"a.until(a + x.suc) = a.until(a + x) + List.singleton(a + x)","proof":["a.range + a.until(a + x) + List.singleton(a + x) = a.range + (a.until(a + x) + List.singleton(a + x))"]}
{"goal":"a.range + a.until(a + x.suc) = a.range + (a.until(a + x) + List.singleton(a + x))","proof":["a.until(a + x) + List.singleton(a + x) != a.until(a + x.suc)"]}
{"goal":"a.range + a.until(a + x) + List.singleton(a + x) = (a + x).range + List.singleton(a + x)","proof":["a.range + a.until(a + x) != (a + x).range"]}
{"goal":"f(x)","proof":[]}
{"goal":"(a + x).range + List.singleton(a + x) = (a + x).suc.range","proof":["(a + x.suc).range != (a + x).suc.range","x.suc != x.suc or a + x.suc = (a + x).suc","a + x.suc != (a + x).suc"]}
{"goal":"f(x.suc)","proof":["a.range + a.until(a + x.suc) != (a + x.suc).range or f(x.suc)","a.range + a.until(a + x.suc) != (a + x.suc).range"]}
{"goal":"f(k)","proof":["let s0: Nat -> Bool -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not f(s0(f)) or f(s0(f).suc)","not f(s0(f).suc) or not f(0) or f(k)","not f(s0(f).suc)","not f(0) or f(s0(f)) or f(k)","not f(s0(f))","f(s0(f))"]}
{"goal":"a + k = b","proof":[]}
{"goal":"range_add_until","proof":["not f(k) or a.range + a.until(a + k) = (a + k).range","a.range + a.until(b) != (a + k).range","a.range + a.until(a + k) = (a + k).range","a.range + a.until(a + k) != (a + k).range"]}
{"goal":"m >= max_list(List.cons(head, tail))","proof":["List.cons(head, tail) != List.cons(head, tail) or head.max(max_list(tail)) = max_list(List.cons(head, tail))","m <= m = m >= m","m <= m","not m <= m or m >= m","head.max(max_list(tail)) = max_list(List.cons(head, tail))","not m >= head.max(max_list(tail))","not m >= head.max(k)","not m >= m"]}
{"goal":"m >= max_list(tail)","proof":["not head.max(k) >= max_list(tail)","head.max(k) >= k"]}
{"goal":"head = x implies x <= m","proof":["x <= m = m >= x","not m >= x","not m >= head","head.max(k) >= head"]}
{"goal":"tail.contains(x) implies x <= m","proof":["not x ∈ tail or not f(tail) or x <= max_list(tail)","not lib(util).is_transitive[Nat](Nat.lte) or not x <= max_list(tail) or not max_list(tail) <= m or x <= m","max_list(tail) <= m = m >= max_list(tail)","not x <= max_list(tail) or not max_list(tail) <= m","max_list(tail) <= m","x <= max_list(tail)","not x <= max_list(tail)"]}
{"goal":"List.cons(head, tail).contains(x) implies x <= m","proof":["List.cons(head, tail) != List.cons(head, tail) or not x ∈ List.cons(head, tail) or x ∈ tail or x = head","List.cons(head, tail) != List.cons(head, tail) or not x ∈ List.cons(head, tail) or x = head","List.cons(head, tail) != List.cons(head, tail) or not x ∈ List.cons(head, tail)"]}
{"goal":"f(List.cons(head, tail))","proof":["let s0: List[Nat] -> Nat satisfy { forall(x0: List[Nat], x1: Nat) { not x1 ∈ x0 or not f(x0) or x1 <= max_list(x0) } and forall(x2: List[Nat]) { s0(x2) ∈ x2 or f(x2) } and forall(x3: List[Nat]) { not s0(x3) <= max_list(x3) or f(x3) } }","s0(List.cons(head, tail)) ∈ List.cons(head, tail) or f(List.cons(head, tail))","not s0(List.cons(head, tail)) <= max_list(List.cons(head, tail)) or f(List.cons(head, tail))","not s0(List.cons(head, tail)) ∈ List.cons(head, tail) or s0(List.cons(head, tail)) <= m","List.cons(head, tail) != List.cons(head, tail) or head.max(max_list(tail)) = max_list(List.cons(head, tail))","s0(List.cons(head, tail)) ∈ List.cons(head, tail)","not s0(List.cons(head, tail)) <= max_list(List.cons(head, tail))","head.max(max_list(tail)) = max_list(List.cons(head, tail))","s0(List.cons(head, tail)) <= m"]}
{"goal":"f(list)","proof":["let (s0: List[Nat] -> Bool -> Nat, s1: List[Nat] -> Bool -> List[Nat]) satisfy { forall(x0: List[Nat] -> Bool, x1: List[Nat]) { not x0(List.nil[Nat]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[Nat] -> Bool, x3: List[Nat]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[Nat]) or x2(x3) } }","not f(s1(f)) or f(List.cons(s0(f), s1(f)))","let s2: List[Nat] -> Nat satisfy { forall(x4: List[Nat], x5: Nat) { not x5 ∈ x4 or not f(x4) or x5 <= max_list(x4) } and forall(x6: List[Nat]) { s2(x6) ∈ x6 or f(x6) } and forall(x7: List[Nat]) { not s2(x7) <= max_list(x7) or f(x7) } }","s2(List.nil[Nat]) ∈ List.nil[Nat] or f(List.nil[Nat])","not f(List.cons(s0(f), s1(f))) or not f(List.nil[Nat]) or f(list)","not f(List.nil[Nat]) or f(s1(f)) or f(list)","not f(List.nil[Nat]) or f(s1(f))","not s2(List.nil[Nat]) ∈ List.nil[Nat] or List.nil[Nat] != List.nil[Nat]","not s2(List.nil[Nat]) ∈ List.nil[Nat]","f(List.nil[Nat])","f(s1(f))","not f(List.cons(s0(f), s1(f)))"]}
{"goal":"list_has_max","proof":["let s0: Nat satisfy { s0 ∈ list and not s0 <= n }","not s0 ∈ list or not f(list) or s0 <= max_list(list)","s0 <= max_list(list)","not s0 <= max_list(list) or not max_list(list) <= n or s0 <= n","not s0 <= max_list(list) or not max_list(list) <= n"]}
{"goal":"no_list_contains_nat","proof":["max_list(list).suc ∈ list","not max_list(list) <= max_list(list) or not max_list(list).suc ∈ list or max_list(list).suc <= max_list(list)","not max_list(list).suc <= max_list(list) or not max_list(list) < max_list(list).suc","max_list(list) < max_list(list).suc","max_list(list) <= max_list(list)","not max_list(list) <= max_list(list) or max_list(list).suc <= max_list(list)","max_list(list).suc <= max_list(list)","not max_list(list) < max_list(list).suc"]}
{"goal":"p(List.nil[T])","proof":["item ∈ List.nil[T] or p(List.nil[T])","item ∈ List.nil[T]","not item ∈ List.nil[T] or List.nil[T] != List.nil[T]"]}
{"goal":"p(List.cons(head, tail))","proof":["not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length or p(List.cons(head, tail))","List.cons(head, tail) != List.cons(head, tail) or head != item or List.cons(head, tail).find_first_idx(item) = 0","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","0 < tail.length.suc or tail.length.suc < 0 or tail.length.suc = 0","not tail.length.suc < 0","tail.length.suc != 0","List.cons(head, tail).length = tail.length.suc","head != item or List.cons(head, tail).find_first_idx(item) = 0","not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length","List.cons(head, tail).find_first_idx(item) = 0","not List.cons(head, tail).find_first_idx(item) < tail.length.suc","not 0 < tail.length.suc"]}
{"goal":"tail.find_first_idx(item) < tail.length","proof":["not item ∈ tail or not p(tail) or tail.find_first_idx(item) < tail.length","not item ∈ tail","not item ∈ List.cons(head, tail) or List.cons(head, tail) != List.cons(head, tail) or item ∈ tail or head = item","not item ∈ List.cons(head, tail) or item ∈ tail or head = item"]}
{"goal":"p(List.cons(head, tail))","proof":["not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length or p(List.cons(head, tail))","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item) or head = item","not tail.find_first_idx(item) < tail.length or 1 + tail.find_first_idx(item) < 1 + tail.length","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","1 + tail.length = tail.length.suc","List.cons(head, tail).length = tail.length.suc","not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item)","List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item)","1 + tail.find_first_idx(item) < 1 + tail.length","not 1 + tail.find_first_idx(item) < List.cons(head, tail).length","not 1 + tail.find_first_idx(item) < tail.length.suc"]}
{"goal":"p(list)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","item ∈ List.cons(s0(p), s1(p)) or p(List.cons(s0(p), s1(p)))","not item ∈ List.cons(s0(p), s1(p)) or not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p)))","not item ∈ List.cons(s0(p), s1(p))","item ∈ List.cons(s0(p), s1(p))"]}
{"goal":"find_first_idx_contains","proof":["not item ∈ list or not p(list) or list.find_first_idx(item) < list.length"]}
{"goal":"p(List.nil[T])","proof":["item ∈ List.nil[T] or p(List.nil[T])","item ∈ List.nil[T]","not item ∈ List.nil[T] or List.nil[T] != List.nil[T]"]}
{"goal":"List.cons(head, tail).get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != List.cons(head, tail) or 0 > 0 or List.cons(head, tail).get_idx(0) = Option.some(head)","0 > 0 = 0 < 0","not 0 < 0","List.cons(head, tail) != List.cons(head, tail) or 0 > 0","0 > 0"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item) or p(List.cons(head, tail))","List.cons(head, tail) != List.cons(head, tail) or head != item or List.cons(head, tail).find_first_idx(item) = 0","List.cons(head, tail).get_idx(0) = Option.some(item)","head != item or List.cons(head, tail).find_first_idx(item) = 0","List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item)","List.cons(head, tail).find_first_idx(item) = 0"]}
{"goal":"List.cons(head, tail).find_first_idx(item) = 1 + idx","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item) or head = item","List.cons(head, tail).find_first_idx(item) != 1 + tail.find_first_idx(item)","List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item) or head = item"]}
{"goal":"idx.suc > 0","proof":["idx.suc > 0 = 0 < idx.suc","not 0 < idx.suc","0 < 0 + idx.suc","0 + idx.suc = idx.suc"]}
{"goal":"idx.suc - 1 = idx","proof":["idx + 1 != idx.suc or idx.suc - 1 = idx","idx + 1 != idx.suc","idx + 1 = 1 + idx","1 + idx = idx.suc"]}
{"goal":"List.cons(head, tail).get_idx(1 + idx) = tail.get_idx(idx)","proof":["not idx.suc > 0 or List.cons(head, tail) != List.cons(head, tail) or tail.get_idx(idx.suc - 1) = List.cons(head, tail).get_idx(idx.suc)","1 + idx = idx.suc","not idx.suc > 0 or tail.get_idx(idx.suc - 1) = List.cons(head, tail).get_idx(idx.suc)","List.cons(head, tail).get_idx(1 + idx) != tail.get_idx(idx.suc - 1)","tail.get_idx(idx.suc - 1) != List.cons(head, tail).get_idx(idx.suc)"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item) or p(List.cons(head, tail))","not item ∈ tail or not p(tail) or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","not item ∈ List.cons(head, tail) or List.cons(head, tail) != List.cons(head, tail) or item ∈ tail or head = item","List.cons(head, tail) != List.cons(head, tail) or not item ∈ List.cons(head, tail) or item ∈ tail","not item ∈ List.cons(head, tail) or item ∈ tail","item ∈ tail","List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item)","List.cons(head, tail).get_idx(1 + idx) != Option.some(item)","tail.get_idx(idx) != Option.some(item)","tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","tail.get_idx(tail.find_first_idx(item)) != Option.some(item)"]}
{"goal":"p(list)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","item ∈ List.cons(s0(p), s1(p)) or p(List.cons(s0(p), s1(p)))","not item ∈ List.cons(s0(p), s1(p)) or not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p)))","not item ∈ List.cons(s0(p), s1(p))","item ∈ List.cons(s0(p), s1(p))"]}
{"goal":"find_first_idx_get_idx","proof":["not item ∈ list or not p(list) or list.get_idx(list.find_first_idx(item)) = Option.some(item)"]}
{"goal":"p(List.nil[T])","proof":["i + 1 < List.nil[T].length or p(List.nil[T])","i + 1 < List.nil[T].length","List.nil[T] != List.nil[T] or List.nil[T].length = 0","not i + 1 < 0","List.nil[T].length = 0"]}
{"goal":"i + 1 > 0","proof":["i.suc > 0 = 0 < i.suc","0 < 0 + i.suc","i + 1 = 1 + i","not 1 + i > 0","1 + i = i.suc","not i.suc > 0","not 0 < i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["not i + 1 > 0 or List.cons(head, tail) != List.cons(head, tail) or tail.get_idx(i + 1 - 1) = List.cons(head, tail).get_idx(i + 1)","i + 1 - 1 = i","not i + 1 > 0 or tail.get_idx(i + 1 - 1) = List.cons(head, tail).get_idx(i + 1)","tail.get_idx(i + 1 - 1) != List.cons(head, tail).get_idx(i + 1)"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(i + 1) != List.cons(head, tail).tail.get_idx(i) or p(List.cons(head, tail))","List.cons(head, tail).tail = tail","List.cons(head, tail).get_idx(i + 1) != List.cons(head, tail).tail.get_idx(i)"]}
{"goal":"p(list)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","i + 1 < List.cons(s0(p), s1(p)).length or p(List.cons(s0(p), s1(p)))","not i + 1 < List.cons(s0(p), s1(p)).length or not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p)))","not i + 1 < List.cons(s0(p), s1(p)).length","i + 1 < List.cons(s0(p), s1(p)).length"]}
{"goal":"get_idx_succ_implies_tail","proof":["not i + 1 < list.length or not p(list) or list.get_idx(i + 1) = list.tail.get_idx(i)"]}
{"goal":"p(List.nil[T])","proof":["List.nil[T].count(item) > 1 or p(List.nil[T])","List.nil[T].count(item) > 1","List.nil[T] != List.nil[T] or List.nil[T].count(item) = 0","List.nil[T].count(item) > 1 = 1 < List.nil[T].count(item)","1 < List.nil[T].count(item)","not 1 < 0","List.nil[T].count(item) = 0"]}
{"goal":"tail.contains(item)","proof":["List.cons(item, tail) != List.cons(item, tail) or item != item or List.cons(item, tail).count(item) = 1 + tail.count(item)","tail.count(item) = 0 or item ∈ tail","tail.count(item) = 0","List.cons(head, tail).count(item) > 1 = 1 < List.cons(head, tail).count(item)","not 1 < List.cons(head, tail).count(item) or List.cons(head, tail).count(item) != 1","1 + 0 = 1","1 < List.cons(head, tail).count(item)","item != item or List.cons(item, tail).count(item) = 1 + tail.count(item)","List.cons(head, tail).count(item) != 1","List.cons(item, tail).count(item) = 1 + tail.count(item)"]}
{"goal":"idx < tail.length","proof":["not item ∈ tail or tail.find_first_idx(item) < tail.length","not tail.find_first_idx(item) < tail.length","tail.find_first_idx(item) < tail.length"]}
{"goal":"idx + 1 < tail.length + 1","proof":["not idx < tail.length or 1 + idx < 1 + tail.length","idx + 1 = 1 + idx","tail.length + 1 = 1 + tail.length","not 1 + idx < tail.length + 1","not 1 + idx < 1 + tail.length"]}
{"goal":"List.cons(head, tail).get_idx(idx + 1) = tail.get_idx(idx)","proof":["not idx + 1 > 0 or List.cons(head, tail) != List.cons(head, tail) or tail.get_idx(idx + 1 - 1) = List.cons(head, tail).get_idx(idx + 1)","List.cons(item, tail) != List.cons(item, tail) or idx + 1 > 0 or List.cons(item, tail).get_idx(idx + 1) = Option.some(item)","not item ∈ tail or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","idx + 1 - 1 = idx","List.cons(item, tail).get_idx(idx + 1) = Option.some(item) or idx + 1 > 0","not idx + 1 > 0 or tail.get_idx(idx + 1 - 1) = List.cons(head, tail).get_idx(idx + 1)","List.cons(head, tail).get_idx(idx + 1) != tail.get_idx(tail.find_first_idx(item))","tail.get_idx(idx + 1 - 1) != List.cons(head, tail).get_idx(idx + 1)","tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","List.cons(head, tail).get_idx(idx + 1) != Option.some(item)","List.cons(item, tail).get_idx(idx + 1) != Option.some(item)","not idx + 1 > 0","idx + 1 > 0"]}
{"goal":"List.cons(head, tail).get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != List.cons(head, tail) or 0 > 0 or List.cons(head, tail).get_idx(0) = Option.some(head)","0 > 0 = 0 < 0","not 0 < 0","List.cons(head, tail) != List.cons(head, tail) or 0 > 0","0 > 0"]}
{"goal":"idx + 1 > 0","proof":["idx.suc > 0 = 0 < idx.suc","0 < 0 + idx.suc","idx + 1 = 1 + idx","not 1 + idx > 0","1 + idx = idx.suc","not idx.suc > 0","not 0 < idx.suc","0 + idx.suc = idx.suc"]}
{"goal":"0 < j","proof":["not 0 < idx + 1","idx + 1 > 0 = 0 < idx + 1"]}
{"goal":"j < List.cons(head, tail).length","proof":["not j < List.cons(item, tail).length","List.cons(item, tail) != List.cons(item, tail) or List.cons(item, tail).length = tail.length.suc","tail.length + 1 = tail.length.suc","idx + 1 < tail.length.suc","j < tail.length.suc","List.cons(item, tail).length = tail.length.suc"]}
{"goal":"List.cons(head, tail).get_idx(0) = Option.some(head)","proof":[]}
{"goal":"List.cons(head, tail).get_idx(j) = tail.get_idx(idx)","proof":["List.cons(head, tail).get_idx(idx + 1) != tail.get_idx(idx)"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(0) != Option.some(item) or List.cons(head, tail).get_idx(j) != Option.some(item) or not j < List.cons(head, tail).length or not 0 < j or p(List.cons(head, tail))","not item ∈ tail or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","List.cons(head, tail).get_idx(0) = Option.some(item)","List.cons(head, tail).get_idx(j) != Option.some(item) or List.cons(head, tail).get_idx(0) != Option.some(item) or not 0 < j","List.cons(head, tail).get_idx(j) != Option.some(item)","tail.get_idx(idx) != Option.some(item)","tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","tail.get_idx(tail.find_first_idx(item)) != Option.some(item)"]}
{"goal":"List.cons(head, tail).count(item) > 1","proof":[]}
{"goal":"tail.count(item) > 1","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).count(item) = tail.count(item) or head = item","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).count(item) = tail.count(item)","List.cons(head, tail).count(item) = tail.count(item)"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < tail.length and tail.get_idx(k0) = Option.some(item) and tail.get_idx(k1) = Option.some(item) }","proof":["let (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.count(item) > 1 or not p(x1) or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.count(item) > 1 or not p(x2) or x2.get_idx(s0(x2)) = Option.some(item) } and forall(x3: List[T]) { not x3.count(item) > 1 or not p(x3) or x3.get_idx(s1(x3)) = Option.some(item) } and forall(x4: List[T]) { x4.count(item) > 1 or p(x4) } and forall(x5: List[T], x6: Nat, x7: Nat) { Option.some(item) != x5.get_idx(x6) or Option.some(item) != x5.get_idx(x7) or not x7 < x5.length or not x6 < x7 or p(x5) } }","not s1(tail) < tail.length or tail.get_idx(s1(tail)) != Option.some(item) or tail.get_idx(s0(tail)) != Option.some(item) or not s0(tail) < s1(tail)","not s1(tail) < tail.length or tail.get_idx(s0(tail)) != Option.some(item) or tail.get_idx(s1(tail)) != Option.some(item) or not s0(tail) < s1(tail)","not tail.count(item) > 1 or not p(tail) or s1(tail) < tail.length","not tail.count(item) > 1 or not p(tail) or s0(tail) < s1(tail)","not tail.count(item) > 1 or not p(tail) or tail.get_idx(s1(tail)) = Option.some(item)","not tail.count(item) > 1 or not p(tail) or tail.get_idx(s0(tail)) = Option.some(item)","s0(tail) < s1(tail)","s1(tail) < tail.length","tail.get_idx(s0(tail)) = Option.some(item)","tail.get_idx(s1(tail)) = Option.some(item)","tail.get_idx(s1(tail)) != Option.some(item)"]}
{"goal":"i + 1 > 0","proof":["i.suc > 0 = 0 < i.suc","0 < 0 + i.suc","i + 1 = 1 + i","not 1 + i > 0","1 + i = i.suc","not i.suc > 0","not 0 < i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["not i + 1 > 0 or List.cons(head, tail) != List.cons(head, tail) or tail.get_idx(i + 1 - 1) = List.cons(head, tail).get_idx(i + 1)","i + 1 - 1 = i","not i + 1 > 0 or tail.get_idx(i + 1 - 1) = List.cons(head, tail).get_idx(i + 1)","tail.get_idx(i + 1 - 1) != List.cons(head, tail).get_idx(i + 1)"]}
{"goal":"j + 1 > 0","proof":["j.suc > 0 = 0 < j.suc","0 < 0 + j.suc","j + 1 = 1 + j","not 1 + j > 0","1 + j = j.suc","not j.suc > 0","not 0 < j.suc","0 + j.suc = j.suc"]}
{"goal":"List.cons(head, tail).get_idx(j + 1) = tail.get_idx(j)","proof":["not j + 1 > 0 or List.cons(head, tail) != List.cons(head, tail) or tail.get_idx(j + 1 - 1) = List.cons(head, tail).get_idx(j + 1)","j + 1 - 1 = j","not j + 1 > 0 or tail.get_idx(j + 1 - 1) = List.cons(head, tail).get_idx(j + 1)","tail.get_idx(j + 1 - 1) != List.cons(head, tail).get_idx(j + 1)"]}
{"goal":"j + 1 < List.cons(head, tail).length","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","not tail.length.suc <= j.suc or tail.length <= j","not tail.length <= j or not j < tail.length","List.cons(head, tail).length <= j + 1 or j + 1 < List.cons(head, tail).length","j + 1 = j.suc","List.cons(head, tail).length <= j + 1","not tail.length <= j","List.cons(head, tail).length <= j.suc","List.cons(head, tail).length = tail.length.suc","not tail.length.suc <= j.suc","tail.length.suc <= j.suc"]}
{"goal":"i + 1 < j + 1","proof":["not i < j or 1 + i < 1 + j","i + 1 = 1 + i","j + 1 = 1 + j","not 1 + i < j + 1","not 1 + i < 1 + j"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(i.suc) != Option.some(item) or List.cons(head, tail).get_idx(j.suc) != Option.some(item) or not j.suc < List.cons(head, tail).length or not i.suc < j.suc or p(List.cons(head, tail))","i + 1 = i.suc","j + 1 = j.suc","i.suc < j + 1","j.suc < List.cons(head, tail).length","i.suc < j.suc","List.cons(head, tail).get_idx(i + 1) = Option.some(item)","List.cons(head, tail).get_idx(j + 1) = Option.some(item)","List.cons(head, tail).get_idx(j.suc) = Option.some(item)","List.cons(head, tail).get_idx(i.suc) = Option.some(item)","not j.suc < List.cons(head, tail).length or List.cons(head, tail).get_idx(i.suc) != Option.some(item) or List.cons(head, tail).get_idx(j.suc) != Option.some(item) or not i.suc < j.suc"]}
{"goal":"p(list)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","List.cons(s0(p), s1(p)).count(item) > 1 or p(List.cons(s0(p), s1(p)))","not List.cons(s0(p), s1(p)).count(item) > 1 or not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p)))","not List.cons(s0(p), s1(p)).count(item) > 1","List.cons(s0(p), s1(p)).count(item) > 1"]}
{"goal":"duplicate_implies_duplicate_idx","proof":["let (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.count(item) > 1 or not p(x1) or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.count(item) > 1 or not p(x2) or x2.get_idx(s0(x2)) = Option.some(item) } and forall(x3: List[T]) { not x3.count(item) > 1 or not p(x3) or x3.get_idx(s1(x3)) = Option.some(item) } and forall(x4: List[T]) { x4.count(item) > 1 or p(x4) } and forall(x5: List[T], x6: Nat, x7: Nat) { Option.some(item) != x5.get_idx(x6) or Option.some(item) != x5.get_idx(x7) or not x7 < x5.length or not x6 < x7 or p(x5) } }","not s1(list) < list.length or list.get_idx(s1(list)) != Option.some(item) or list.get_idx(s0(list)) != Option.some(item) or not s0(list) < s1(list)","not s1(list) < list.length or list.get_idx(s0(list)) != Option.some(item) or list.get_idx(s1(list)) != Option.some(item) or not s0(list) < s1(list)","not list.count(item) > 1 or not p(list) or s1(list) < list.length","not list.count(item) > 1 or not p(list) or s0(list) < s1(list)","not list.count(item) > 1 or not p(list) or list.get_idx(s1(list)) = Option.some(item)","not list.count(item) > 1 or not p(list) or list.get_idx(s0(list)) = Option.some(item)","s0(list) < s1(list)","s1(list) < list.length","list.get_idx(s0(list)) = Option.some(item)","list.get_idx(s1(list)) = Option.some(item)","list.get_idx(s1(list)) != Option.some(item)"]}
{"goal":"index_pigeonhole","proof":["let (s0: (List[T], T) -> Nat, s1: (List[T], T) -> Nat) satisfy { forall(x0: List[T], x1: T) { not x0.count(x1) > 1 or s0(x0, x1) < s1(x0, x1) } and forall(x2: List[T], x3: T) { not x2.count(x3) > 1 or s1(x2, x3) < x2.length } and forall(x4: List[T], x5: T) { not x4.count(x5) > 1 or x4.get_idx(s0(x4, x5)) = Option.some(x5) } and forall(x6: List[T], x7: T) { not x6.count(x7) > 1 or x6.get_idx(s1(x6, x7)) = Option.some(x7) } }","let s2: List[T] -> T satisfy { forall(x8: List[T]) { not x8.unique.length < x8.length or x8.count(s2(x8)) > 1 } }","not s1(list, s2(list)) < list.length or list.get_idx(s1(list, s2(list))) != list.get_idx(s0(list, s2(list))) or not s0(list, s2(list)) < s1(list, s2(list))","not list.count(s2(list)) > 1 or list.get_idx(s1(list, s2(list))) = Option.some(s2(list))","not list.count(s2(list)) > 1 or list.get_idx(s0(list, s2(list))) = Option.some(s2(list))","not list.count(s2(list)) > 1 or s0(list, s2(list)) < s1(list, s2(list))","not list.unique.length < list.length or list.count(s2(list)) > 1","not list.count(s2(list)) > 1 or s1(list, s2(list)) < list.length","list.count(s2(list)) > 1","s1(list, s2(list)) < list.length","s0(list, s2(list)) < s1(list, s2(list))","list.get_idx(s0(list, s2(list))) = Option.some(s2(list))","list.get_idx(s1(list, s2(list))) = Option.some(s2(list))","list.get_idx(s1(list, s2(list))) != list.get_idx(s0(list, s2(list)))","list.get_idx(s1(list, s2(list))) = list.get_idx(s0(list, s2(list)))"]}
{"goal":"List.nil[T].length = 0","proof":["List.nil[T] != List.nil[T] or List.nil[T].length = 0"]}
{"goal":"not 0 > 0","proof":["not 0 ∈ 0.range or not 0 >= 0","not 0 < 0 or 0 ∈ 0.range","not 0 < 0 or 0 <= 0","0 <= 0 = 0 >= 0","0 > 0 = 0 < 0","0 < 0","0 <= 0","0 ∈ 0.range","0 >= 0","not 0 >= 0"]}
{"goal":"pl(0, l)","proof":["0 < l.length or pl(0, l)","0 < l.length","0 > 0 = 0 < 0"]}
{"goal":"l.get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != l or 0 > 0 or l.get_idx(0) = Option.some(head)","0 > 0 = 0 < 0","not 0 < 0","List.cons(head, tail) != l or 0 > 0","0 > 0"]}
{"goal":"pl(0, l)","proof":["l.get_idx(0) != Option.some(head) or pl(0, l)"]}
{"goal":"p(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) } and forall(x2: Nat) { not pl(x2, s0(x2)) or p(x2) } }","pl(0, s0(0))","not pl(0, s0(0)) or p(0)"]}
{"goal":"pl(i + 1, l)","proof":["i + 1 < l.length or pl(i + 1, l)","l.length <= i + 1 = i + 1 >= l.length","not l.length <= i + 1 or not i + 1 < l.length","i + 1 < l.length","l.length <= i + 1","not l.length <= i + 1"]}
{"goal":"i + 1 < l.length","proof":["l.length <= i + 1 = i + 1 >= l.length","l.length <= i + 1 or i + 1 < l.length","not l.length <= i + 1","l.length <= i + 1"]}
{"goal":"not 0 > i + 1","proof":["not i + 1 < 0 or i + 1 <= 0","0 > i + 1 = i + 1 < 0","i + 1 < 0","not i + 1 < 0 or i + 1 != 0","i + 1 != 0","not i + 1 <= 0 or i + 1 = 0","i + 1 <= 0","not i + 1 <= 0"]}
{"goal":"false","proof":["List.nil[T] != l or l.length = 0","not i + 1 < 0","l.length = 0"]}
{"goal":"0 < i + 1","proof":["0 < 0 + i.suc","i + 1 = 1 + i","not 0 < 1 + i","1 + i = i.suc","not 0 < i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["l.get_idx(i + 1) != tail.get_idx(i)","not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)","List.cons(head, tail) != l or l.tail = tail","l.tail = tail","l.get_idx(i + 1) = l.tail.get_idx(i)","l.get_idx(i + 1) != l.tail.get_idx(i)"]}
{"goal":"pl(i, tail)","proof":["not p(i) or pl(i, tail)"]}
{"goal":"exists(k0: T) { tail.get_idx(i) = Option.some(k0) }","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { x2 < x3.length or pl(x2, x3) } and forall(x4: List[T], x5: Nat, x6: T) { x4.get_idx(x5) != Option.some(x6) or pl(x5, x4) } }","Option.some(s0(i, tail)) != tail.get_idx(i)","not i < tail.length or not pl(i, tail) or Option.some(s0(i, tail)) = tail.get_idx(i)","not i < tail.length","List.cons(head, tail) != l or tail.length.suc = l.length","not i.suc < tail.length.suc or i < tail.length","i + 1 = i.suc","i.suc < l.length","tail.length.suc = l.length","not i.suc < tail.length.suc","i.suc < tail.length.suc"]}
{"goal":"pl(i + 1, l)","proof":["let s0: T satisfy { tail.get_idx(i) = Option.some(s0) }","l.get_idx(i + 1) != Option.some(s0) or pl(i + 1, l)","l.get_idx(i + 1) = tail.get_idx(i)","l.get_idx(i + 1) != Option.some(s0)"]}
{"goal":"pl(i + 1, l)","proof":[]}
{"goal":"p(i + 1)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) } and forall(x2: Nat) { not pl(x2, s0(x2)) or p(x2) } }","pl(i + 1, s0(i + 1))","not pl(i + 1, s0(i + 1)) or p(i + 1)"]}
{"goal":"p(idx)","proof":["let s0: Nat -> Bool -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p) + 1)","not p(s0(p).suc) or not p(0) or p(idx)","not p(s0(p).suc)","not p(0) or p(s0(p)) or p(idx)","p(s0(p))","s0(p) + 1 = s0(p).suc","p(s0(p) + 1)","not p(s0(p) + 1)"]}
{"goal":"get_idx_always_some","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { x2 < x3.length or pl(x2, x3) } and forall(x4: List[T], x5: Nat, x6: T) { x4.get_idx(x5) != Option.some(x6) or pl(x5, x4) } }","Option.some(s0(idx, list)) != list.get_idx(idx)","not p(idx) or pl(idx, list)","not idx < list.length or not pl(idx, list) or Option.some(s0(idx, list)) = list.get_idx(idx)","not pl(idx, list)"]}
{"goal":"pf(0, l)","proof":["0 < l.length or pf(0, l)","0 < l.length","List.nil[T] != l or l.length = 0","not 0 < l.length or l.length != 0","l.length = 0","l.length != 0"]}
{"goal":"l.get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != l or 0 > 0 or l.get_idx(0) = Option.some(head)","0 > 0 = 0 < 0","not 0 < 0","List.cons(head, tail) != l or 0 > 0","0 > 0"]}
{"goal":"map[T, U](l, f).get_idx(0) = Option.some(f(head))","proof":["List.cons(head, tail) != l or List.cons(f(head), map[T, U](tail, f)) = map[T, U](l, f)","List.cons(f(head), map[T, U](tail, f)) != map[T, U](l, f) or 0 > 0 or map[T, U](l, f).get_idx(0) = Option.some(f(head))","0 > 0 = 0 < 0","not 0 < 0","not 0 > 0 or 0 < 0","List.cons(f(head), map[T, U](tail, f)) != map[T, U](l, f) or 0 > 0","List.cons(f(head), map[T, U](tail, f)) = map[T, U](l, f)","0 > 0"]}
{"goal":"pf(0, l)","proof":["map[T, U](l, f).get_idx(0) != Option.some(f(head)) or l.get_idx(0) != Option.some(head) or pf(0, l)"]}
{"goal":"p(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) } and forall(x2: Nat) { not pf(x2, s0(x2)) or p(x2) } }","pf(0, s0(0))","not pf(0, s0(0)) or p(0)"]}
{"goal":"pf(i + 1, l)","proof":["i + 1 < l.length or pf(i + 1, l)","l.length <= i + 1 = i + 1 >= l.length","not l.length <= i + 1 or not i + 1 < l.length","i + 1 < l.length","l.length <= i + 1","not l.length <= i + 1"]}
{"goal":"i + 1 > 0","proof":["i.suc > 0 = 0 < i.suc","0 < 0 + i.suc","i + 1 = 1 + i","not 1 + i > 0","1 + i = i.suc","not i.suc > 0","not 0 < i.suc","0 + i.suc = i.suc"]}
{"goal":"false","proof":["not 0 < i + 1 or 0 <= i + 1","l.length <= i + 1 = i + 1 >= l.length","i + 1 > 0 = 0 < i + 1","0 < i + 1","List.nil[T] != l or l.length = 0","l.length = 0","not l.length <= i + 1","0 <= i + 1","not 0 <= i + 1"]}
{"goal":"l.get_idx(i + 1) = tail.get_idx(i)","proof":["not i + 1 > 0 or List.cons(head, tail) != l or tail.get_idx(i + 1 - 1) = l.get_idx(i + 1)","i + 1 - 1 = i","tail.get_idx(i + 1 - 1) != l.get_idx(i + 1)","not i + 1 > 0 or tail.get_idx(i + 1 - 1) = l.get_idx(i + 1)"]}
{"goal":"i < tail.length","proof":["List.cons(head, tail) != l or tail.length.suc = l.length","not i.suc < tail.length.suc or i < tail.length","l.length <= i.suc = i.suc >= l.length","l.length <= i.suc or i.suc < l.length","not i.suc < tail.length.suc","i + 1 = i.suc","not i.suc >= l.length","tail.length.suc = l.length","not i.suc < l.length","not l.length <= i.suc","l.length <= i.suc"]}
{"goal":"pf(i, tail)","proof":["not p(i) or pf(i, tail)"]}
{"goal":"exists(k0: T) { tail.get_idx(i) = Option.some(k0) and map[T, U](tail, f).get_idx(i) = Option.some(f(k0)) }","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { not x2 < x3.length or not pf(x2, x3) or Option.some(f(s0(x2, x3))) = map[T, U](x3, f).get_idx(x2) } and forall(x4: Nat, x5: List[T]) { x4 < x5.length or pf(x4, x5) } and forall(x6: List[T], x7: Nat, x8: T) { map[T, U](x6, f).get_idx(x7) != Option.some(f(x8)) or x6.get_idx(x7) != Option.some(x8) or pf(x7, x6) } }","Option.some(f(s0(i, tail))) != map[T, U](tail, f).get_idx(i) or Option.some(s0(i, tail)) != tail.get_idx(i)","not i < tail.length or not pf(i, tail) or Option.some(s0(i, tail)) = tail.get_idx(i)","not i < tail.length or not pf(i, tail) or Option.some(f(s0(i, tail))) = map[T, U](tail, f).get_idx(i)","Option.some(s0(i, tail)) = tail.get_idx(i)","Option.some(f(s0(i, tail))) = map[T, U](tail, f).get_idx(i)","Option.some(f(s0(i, tail))) != map[T, U](tail, f).get_idx(i)"]}
{"goal":"map[T, U](tail, f).get_idx(i) = Option.some(f(x))","proof":[]}
{"goal":"map[T, U](List.cons(head, tail), f) = List.cons(f(head), map[T, U](tail, f))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"map[T, U](List.cons(head, tail), f).get_idx(i + 1) = map[T, U](tail, f).get_idx(i + 1 - 1)","proof":["not i + 1 > 0 or List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f) or map[T, U](List.cons(head, tail), f).get_idx(i + 1) = map[T, U](tail, f).get_idx(i + 1 - 1)","List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f)"]}
{"goal":"i = i + 1 - 1","proof":["i + 1 != i + 1 or i + 1 - 1 = i"]}
{"goal":"map[T, U](l, f).get_idx(i + 1) = Option.some(f(x))","proof":[]}
{"goal":"pf(i + 1, l)","proof":["map[T, U](l, f).get_idx(i + 1) != Option.some(f(x)) or l.get_idx(i + 1) != Option.some(x) or pf(i + 1, l)","l.get_idx(i + 1) = Option.some(x)","l.get_idx(i + 1) != Option.some(x)"]}
{"goal":"pf(i + 1, l)","proof":[]}
{"goal":"p(i + 1)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) } and forall(x2: Nat) { not pf(x2, s0(x2)) or p(x2) } }","pf(i + 1, s0(i + 1))","not pf(i + 1, s0(i + 1)) or p(i + 1)"]}
{"goal":"pf(idx, a)","proof":["not p(idx) or pf(idx, a)","let s0: Nat -> Bool -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p) + 1)","not p(idx)","not p(s0(p).suc) or not p(0) or p(idx)","not p(0) or p(s0(p)) or p(idx)","s0(p) + 1 = s0(p).suc","p(s0(p)) or p(idx)","p(s0(p))","not p(s0(p).suc) or p(idx)","not p(s0(p).suc)","p(s0(p) + 1)","not p(s0(p) + 1)"]}
{"goal":"map_under_idx","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { not x2 < x3.length or not pf(x2, x3) or Option.some(f(s0(x2, x3))) = map[T, U](x3, f).get_idx(x2) } and forall(x4: Nat, x5: List[T]) { x4 < x5.length or pf(x4, x5) } and forall(x6: List[T], x7: Nat, x8: T) { map[T, U](x6, f).get_idx(x7) != Option.some(f(x8)) or x6.get_idx(x7) != Option.some(x8) or pf(x7, x6) } }","Option.some(f(s0(idx, a))) != map[T, U](a, f).get_idx(idx) or Option.some(s0(idx, a)) != a.get_idx(idx)","not idx < a.length or not pf(idx, a) or Option.some(s0(idx, a)) = a.get_idx(idx)","not idx < a.length or not pf(idx, a) or Option.some(f(s0(idx, a))) = map[T, U](a, f).get_idx(idx)","Option.some(s0(idx, a)) = a.get_idx(idx)","Option.some(f(s0(idx, a))) = map[T, U](a, f).get_idx(idx)","Option.some(f(s0(idx, a))) != map[T, U](a, f).get_idx(idx)"]}
{"goal":"fp(0, l)","proof":["0 < l.length or fp(0, l)","0 < l.length","List.nil[T] != l or l.length = 0","not 0 < l.length or l.length != 0","l.length = 0","l.length != 0"]}
{"goal":"l.get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != l or 0 > 0 or l.get_idx(0) = Option.some(head)","0 > 0 = 0 < 0","not 0 < 0","List.cons(head, tail) != l or 0 > 0","0 > 0"]}
{"goal":"(l + b).get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != l or List.cons(head, tail + b) = l + b","List.cons(head, tail + b) != l + b or 0 > 0 or (l + b).get_idx(0) = Option.some(head)","0 > 0 = 0 < 0","not 0 < 0","List.cons(head, tail + b) != l + b or 0 > 0","not 0 > 0 or 0 < 0","List.cons(head, tail + b) = l + b","0 > 0"]}
{"goal":"fp(0, l)","proof":["(l + b).get_idx(0) != l.get_idx(0) or fp(0, l)","(l + b).get_idx(0) = l.get_idx(0)","(l + b).get_idx(0) != l.get_idx(0)"]}
{"goal":"f(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) } and forall(x2: Nat) { not fp(x2, s0(x2)) or f(x2) } }","fp(0, s0(0))","not fp(0, s0(0)) or f(0)"]}
{"goal":"false","proof":["List.nil[T] != l or l.length = 0","not i + 1 < 0","l.length = 0"]}
{"goal":"i + 1 < tail.length + 1","proof":["List.cons(head, tail) != l or tail.length.suc = l.length","tail.length + 1 = 1 + tail.length","not i + 1 < 1 + tail.length","1 + tail.length = tail.length.suc","not i + 1 < tail.length.suc","tail.length.suc = l.length"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = (tail + b).get_idx(i)","proof":["not f(i) or fp(i, tail)","not i < tail.length or not fp(i, tail) or (tail + b).get_idx(i) = tail.get_idx(i)","(tail + b).get_idx(i) != l.get_idx(i + 1)","not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)","not i.suc < tail.length.suc or i < tail.length","List.cons(head, tail) != l or l.tail = tail","i + 1 = i.suc","tail.length + 1 = tail.length.suc","i.suc < tail.length + 1","l.tail = tail","fp(i, tail)","i.suc < tail.length.suc","i < tail.length","l.get_idx(i + 1) = l.tail.get_idx(i)","(tail + b).get_idx(i) != l.tail.get_idx(i)","(tail + b).get_idx(i) = tail.get_idx(i)","(tail + b).get_idx(i) != tail.get_idx(i)"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["l.get_idx(i + 1) != tail.get_idx(i)","not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)","List.cons(head, tail) != l or l.tail = tail","l.tail = tail","l.get_idx(i + 1) = l.tail.get_idx(i)","l.get_idx(i + 1) != l.tail.get_idx(i)"]}
{"goal":"List.cons(head, tail) + b = List.cons(head, tail + b)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + b = List.cons(head, tail + b)"]}
{"goal":"(List.cons(head, tail) + b).get_idx(i + 1) = List.cons(head, tail + b).get_idx(i + 1)","proof":["List.cons(head, tail) + b != List.cons(head, tail + b)"]}
{"goal":"i + 1 > 0","proof":["i.suc > 0 = 0 < i.suc","0 < 0 + i.suc","i + 1 = 1 + i","not 1 + i > 0","1 + i = i.suc","not i.suc > 0","not 0 < i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i)","proof":["not i + 1 > 0 or List.cons(head, tail + b) != List.cons(head, tail + b) or List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i + 1 - 1)","i + 1 - 1 = i","not i + 1 > 0 or List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i + 1 - 1)","List.cons(head, tail + b).get_idx(i + 1) != (tail + b).get_idx(i + 1 - 1)"]}
{"goal":"(l + b).get_idx(i + 1) = l.get_idx(i + 1)","proof":[]}
{"goal":"fp(i + 1, l)","proof":["(l + b).get_idx(i + 1) != l.get_idx(i + 1) or fp(i + 1, l)","(l + b).get_idx(i + 1) != l.get_idx(i + 1)"]}
{"goal":"fp(i + 1, l)","proof":[]}
{"goal":"f(i + 1)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) } and forall(x2: Nat) { not fp(x2, s0(x2)) or f(x2) } }","not fp(i + 1, s0(i + 1)) or f(i + 1)","i + 1 < s0(i + 1).length or fp(i + 1, s0(i + 1))","not i + 1 < s0(i + 1).length or fp(i + 1, s0(i + 1))","not fp(i + 1, s0(i + 1))","not i + 1 < s0(i + 1).length","i + 1 < s0(i + 1).length"]}
{"goal":"append_add_idx_left","proof":["not f(n) or fp(n, a)","let s0: Nat -> Bool -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not f(s0(f)) or f(s0(f) + 1)","not n < a.length or not fp(n, a) or (a + b).get_idx(n) = a.get_idx(n)","not fp(n, a)","not f(s0(f).suc) or not f(0) or f(n)","not f(0) or f(s0(f)) or f(s0(f))","s0(f) + 1 = s0(f).suc","f(s0(f)) or f(s0(f))","f(s0(f))","not f(s0(f).suc) or f(n)","not f(n)","not f(s0(f).suc)","f(s0(f) + 1)","not f(s0(f) + 1)"]}
{"goal":"f(List.nil[T])","proof":["(List.nil[T] + List.singleton(a)).get_idx(List.nil[T].length) != Option.some(a) or f(List.nil[T])","List.cons(a, List.nil[T]) != List.singleton(a) or List.nil[T].length > 0 or List.singleton(a).get_idx(List.nil[T].length) = Option.some(a)","List.nil[T].length > 0 = 0 < List.nil[T].length","not 0 < List.nil[T].length or List.nil[T].length != 0","List.nil[T] != List.nil[T] or List.nil[T].length = 0","List.cons(a, List.nil[T]) = List.singleton(a)","List.nil[T] + List.singleton(a) = List.singleton(a)","List.nil[T].length = 0","(List.nil[T] + List.singleton(a)).get_idx(List.nil[T].length) != Option.some(a)","List.singleton(a).get_idx(List.nil[T].length) != Option.some(a)","List.cons(a, List.nil[T]) != List.singleton(a) or List.nil[T].length > 0","List.nil[T].length > 0","0 < List.nil[T].length"]}
{"goal":"l.length > 0","proof":["List.cons(head, tail) != l or head != head or head ∈ l","l.length < 0 or 0 < l.length or l.length = 0","l.length > 0 = 0 < l.length","not 0 < l.length","l.length != 0 or List.nil[T] = l","not head ∈ l or List.nil[T] != l","not l.length < 0","l.length = 0","List.cons(head, tail) != l or head ∈ l","head ∈ l","List.nil[T] = l","List.nil[T] != l"]}
{"goal":"(l + sa).get_idx(l.length) = (tail + sa).get_idx(l.length - 1)","proof":["not l.length > 0 or List.cons(head, tail + sa) != l + sa or (tail + sa).get_idx(l.length - 1) = (l + sa).get_idx(l.length)","List.cons(head, tail) != l or List.cons(head, tail + sa) = l + sa","List.cons(head, tail + sa) != l + sa","List.cons(head, tail + sa) = l + sa"]}
{"goal":"tail.length = l.length - 1","proof":["List.cons(head, tail) != l or tail.length.suc = l.length","tail.length + 1 != l.length or l.length - 1 = tail.length","tail.length + 1 != l.length","tail.length + 1 = tail.length.suc","tail.length.suc = l.length","tail.length.suc != l.length"]}
{"goal":"(tail + sa).get_idx(l.length - 1) = Option.some(a)","proof":["not f(tail) or (tail + List.singleton(a)).get_idx(tail.length) = Option.some(a)","(tail + sa).get_idx(tail.length) != Option.some(a)","(tail + List.singleton(a)).get_idx(tail.length) = Option.some(a)","(tail + List.singleton(a)).get_idx(tail.length) != Option.some(a)"]}
{"goal":"f(List.cons(head, tail))","proof":["not f(l)","(l + List.singleton(a)).get_idx(l.length) != Option.some(a) or f(l)","(l + sa).get_idx(l.length) = Option.some(a)","(l + List.singleton(a)).get_idx(l.length) != Option.some(a)","(l + List.singleton(a)).get_idx(l.length) = Option.some(a)"]}
{"goal":"append_add_singleton_right","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not f(s1(f)) or f(List.cons(s0(f), s1(f)))","not f(list) or (list + List.singleton(a)).get_idx(list.length) = Option.some(a)","not f(list)","not f(List.cons(s0(f), s1(f))) or not f(List.nil[T]) or f(list)","not f(List.nil[T]) or f(s1(f)) or f(list)","f(s1(f)) or f(list)","f(s1(f))","not f(List.cons(s0(f), s1(f))) or f(list)","not f(List.cons(s0(f), s1(f)))"]}
{"goal":"f(0)","proof":["idx < 0 or f(0)","idx < 0","not idx < 0"]}
{"goal":"(m + 1).range = m.range + List.singleton(m)","proof":["1 + m != m.suc or m.range.append(m) = (1 + m).range","m.range + List.singleton(m) = m.range.append(m)","m + 1 = 1 + m","m.range + List.singleton(m) != (1 + m).range","m.range.append(m) != (1 + m).range","1 + m = m.suc"]}
{"goal":"(m.range + List.singleton(m)).get_idx(idx) = m.range.get_idx(idx)","proof":["not idx < m.range.length or (m.range + List.singleton(m)).get_idx(idx) = m.range.get_idx(idx)","not idx < m.range.length","m.range.length = m"]}
{"goal":"f(m + 1)","proof":["(m + 1).range.get_idx(idx) != Option.some(idx) or f(m + 1)","not idx < m or not f(m) or m.range.get_idx(idx) = Option.some(idx)","(m + 1).range.get_idx(idx) = m.range.get_idx(idx)","(m + 1).range.get_idx(idx) != Option.some(idx)","m.range.get_idx(idx) = Option.some(idx)"]}
{"goal":"idx = m","proof":["not idx < m.suc or idx < m or m = idx","not idx < m.suc","m + 1 = 1 + m","idx < 1 + m","1 + m = m.suc"]}
{"goal":"(m.range + List.singleton(m)).get_idx(m) = Option.some(m)","proof":["(idx.range + List.singleton(m)).get_idx(m) != Option.some(m)","(idx.range + List.singleton(m)).get_idx(idx.range.length) = Option.some(m)","(idx.range + List.singleton(m)).get_idx(idx) != Option.some(m)","idx.range.length = idx"]}
{"goal":"f(m + 1)","proof":["(m + 1).range.get_idx(idx) != Option.some(idx) or f(m + 1)","m.suc != m.suc or m.range.append(m) = m.suc.range","m.range + List.singleton(m) = m.range.append(m)","idx + 1 = 1 + idx","1 + idx = idx.suc","(m + 1).range.get_idx(idx) != Option.some(idx)","m.range.append(m) = m.suc.range"]}
{"goal":"range_idx_eq_idx","proof":["let s0: Nat -> Bool -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","idx < s0(f) + 1 or f(s0(f) + 1)","not idx < s0(f) + 1 or not f(s0(f)) or f(s0(f) + 1)","not idx < n or not f(n) or n.range.get_idx(idx) = Option.some(idx)","not f(n)","not f(s0(f).suc) or not f(0) or f(n)","not f(0) or f(s0(f)) or f(n)","s0(f) + 1 = s0(f).suc","f(s0(f)) or f(n)","f(s0(f))","not f(s0(f).suc) or f(n)","not f(s0(f).suc)","not f(s0(f) + 1)","not idx < s0(f) + 1","idx < s0(f) + 1"]}
{"goal":"n.range.get_idx(idx) = Option.some(idx)","proof":["not idx < n or n.range.get_idx(idx) = Option.some(idx)"]}
{"goal":"exists(k0: Nat) { Option.some(k0) = n.range.get_idx(idx) and map[Nat, T](n.range, f).get_idx(idx) = Option.some(f(k0)) }","proof":["let s0: Nat satisfy { not idx < n.range.length or n.range.get_idx(idx) = Option.some(s0) and (not idx < n.range.length or map[Nat, T](n.range, f).get_idx(idx) = Option.some(f(s0))) }","map[Nat, T](n.range, f).get_idx(idx) != Option.some(f(s0)) or n.range.get_idx(idx) != Option.some(s0)","n.range.length = n","idx < n.range.length","n.range.get_idx(idx) = Option.some(s0)","map[Nat, T](n.range, f).get_idx(idx) = Option.some(f(s0))","map[Nat, T](n.range, f).get_idx(idx) != Option.some(f(s0))"]}
{"goal":"map[Nat, T](n.range, f).get_idx(idx) = Option.some(f(idx))","proof":["let s0: Nat satisfy { n.range.get_idx(idx) = Option.some(s0) and map[Nat, T](n.range, f).get_idx(idx) = Option.some(f(s0)) }","Option.some(f(s0)) != Option.some(f(idx))","f(s0) != f(idx)","s0 != idx","Option.some(s0) = Option.some(idx)","Option.some(s0) != Option.some(idx) or s0 = idx"]}
{"goal":"map_range","proof":[]}
{"goal":"f_out.unique.length < f_out.length","proof":["not n <= f_out.length or not f_out.unique.length < n or f_out.unique.length < f_out.length","f_out.unique.length < n","not f_out.unique.length <= f_out.length or f_out.unique.length < f_out.length or f_out.unique.length = f_out.length","map[Nat, T](n.range, f).length = n.range.length","f_out.unique.length <= f_out.length","f_out.unique.length = f_out.length","f_out.length <= f_out.unique.length = f_out.unique.length >= f_out.length","n <= f_out.length = f_out.length >= n","f_out.length <= f_out.unique.length or f_out.unique.length < f_out.length","f_out.length <= f_out.unique.length","n.range.length = n","not f_out.unique.length < n or not n <= f_out.length","not n <= f_out.length"]}
{"goal":"f_out.length = n","proof":["map[Nat, T](n.range, f).length = n.range.length","map[Nat, T](n.range, f).length != n","n.range.length != n","n.range.length = n"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < n and f_out.get_idx(k0) = f_out.get_idx(k1) }","proof":["let (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.unique.length < x0.length or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.unique.length < x1.length or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.unique.length < x2.length or x2.get_idx(s1(x2)) = x2.get_idx(s0(x2)) } }","f_out.get_idx(s1(f_out)) != f_out.get_idx(s0(f_out)) or not s1(f_out) < n or not s0(f_out) < s1(f_out)","not f_out.unique.length < f_out.length or f_out.get_idx(s1(f_out)) = f_out.get_idx(s0(f_out))","not f_out.unique.length < f_out.length or s1(f_out) < f_out.length","not f_out.unique.length < f_out.length or s0(f_out) < s1(f_out)","s0(f_out) < s1(f_out)","s1(f_out) < f_out.length","s1(f_out) < n","f_out.get_idx(s1(f_out)) = f_out.get_idx(s0(f_out))","f_out.get_idx(s1(f_out)) != f_out.get_idx(s0(f_out))"]}
{"goal":"map[Nat, T](n.range, f).get_idx(i) = Option.some(f(i))","proof":["not i < n or map[Nat, T](n.range, f).get_idx(i) = Option.some(f(i))","not i < n","not n <= i or not j < n or j < i","n <= i or i < n","not j < i or not i < j","not j < i","not n <= i or j < i","n <= i","not n <= i"]}
{"goal":"map[Nat, T](n.range, f).get_idx(j) = Option.some(f(j))","proof":["not j < n or map[Nat, T](n.range, f).get_idx(j) = Option.some(f(j))"]}
{"goal":"f(i) = f(j)","proof":["Option.some(f(j)) != Option.some(f(i)) or f(j) = f(i)","Option.some(f(j)) != Option.some(f(i))"]}
{"goal":"range_pigeonhole","proof":["not j < n or not i < j or f(j) != f(i)","f(j) != f(i)"]}
{"goal":"List.nil[T].get_idx(i) = Option.none[T]","proof":["List.nil[T] != List.nil[T] or List.nil[T].get_idx(i) = Option.none[T]"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> Nat satisfy { forall(x0: Nat, x1: List[T]) { not x0 >= x1.length or not p(x1) or x1.get_idx(x0) = Option.none[T] } and forall(x2: List[T]) { s0(x2) >= x2.length or p(x2) } and forall(x3: List[T]) { x3.get_idx(s0(x3)) != Option.none[T] or p(x3) } }","List.nil[T].get_idx(s0(List.nil[T])) != Option.none[T] or p(List.nil[T])","s0(List.nil[T]) >= List.nil[T].length or p(List.nil[T])","not s0(List.nil[T]) >= List.nil[T].length or List.nil[T].get_idx(s0(List.nil[T])) = Option.none[T]","s0(List.nil[T]) >= List.nil[T].length","List.nil[T].get_idx(s0(List.nil[T])) != Option.none[T]","List.nil[T].get_idx(s0(List.nil[T])) = Option.none[T]"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"i >= tail.length.suc","proof":[]}
{"goal":"false","proof":["tail.length.suc <= i = i >= tail.length.suc","not tail.length.suc <= 0 or tail.length.suc = 0","tail.length.suc != 0","tail.length.suc <= i","tail.length.suc <= 0"]}
{"goal":"i > 0","proof":["i > 0 = 0 < i","not 0 < i","i <= 0 or 0 < i","i <= 0","not i <= 0 or i = 0"]}
{"goal":"exists(k0: Nat) { k0.suc = i }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(i).suc != i","s0(i).suc = i or i = 0"]}
{"goal":"i = i_pred.suc","proof":[]}
{"goal":"List.cons(head, tail).get_idx(i) = tail.get_idx(i_pred)","proof":["not i > 0 or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).get_idx(i) = tail.get_idx(i - 1)","i_pred + 1 != i or i - 1 = i_pred","i_pred + 1 = i_pred.suc","i_pred + 1 = i","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).get_idx(i) = tail.get_idx(i - 1)","List.cons(head, tail).get_idx(i) = tail.get_idx(i - 1)","tail.get_idx(i - 1) != tail.get_idx(i_pred)","i - 1 = i_pred","i - 1 != i_pred"]}
{"goal":"i_pred.suc >= tail.length.suc","proof":["not i >= tail.length.suc"]}
{"goal":"i_pred >= tail.length","proof":["not tail.length.suc <= i_pred.suc or tail.length <= i_pred","tail.length <= i_pred = i_pred >= tail.length","tail.length.suc <= i_pred.suc = i_pred.suc >= tail.length.suc","not tail.length <= i_pred","tail.length.suc <= i_pred.suc","not tail.length.suc <= i_pred.suc"]}
{"goal":"p(tail)","proof":[]}
{"goal":"tail.get_idx(i_pred) = Option.none[T]","proof":["not i_pred >= tail.length or not p(tail) or tail.get_idx(i_pred) = Option.none[T]"]}
{"goal":"List.cons(head, tail).get_idx(i) = Option.none[T]","proof":["List.cons(head, tail).get_idx(i) != tail.get_idx(i_pred)"]}
{"goal":"p(List.cons(head, tail))","proof":["let s0: List[T] -> Nat satisfy { forall(x0: Nat, x1: List[T]) { not x0 >= x1.length or not p(x1) or x1.get_idx(x0) = Option.none[T] } and forall(x2: List[T]) { s0(x2) >= x2.length or p(x2) } and forall(x3: List[T]) { x3.get_idx(s0(x3)) != Option.none[T] or p(x3) } }","List.cons(head, tail).get_idx(s0(List.cons(head, tail))) != Option.none[T] or p(List.cons(head, tail))","s0(List.cons(head, tail)) >= List.cons(head, tail).length or p(List.cons(head, tail))","not s0(List.cons(head, tail)) >= List.cons(head, tail).length or List.cons(head, tail).get_idx(s0(List.cons(head, tail))) = Option.none[T] or s0(List.cons(head, tail)) = 0","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail).length <= s0(List.cons(head, tail)) = s0(List.cons(head, tail)) >= List.cons(head, tail).length","not tail.length.suc <= 0 or tail.length.suc = 0","tail.length.suc != 0","s0(List.cons(head, tail)) >= List.cons(head, tail).length","List.cons(head, tail).get_idx(s0(List.cons(head, tail))) != Option.none[T]","List.cons(head, tail).length = tail.length.suc","s0(List.cons(head, tail)) = 0","List.cons(head, tail).length <= s0(List.cons(head, tail))","List.cons(head, tail).length <= 0","tail.length.suc <= 0"]}
{"goal":"p(list)","proof":["let (s0: List[T] -> Bool -> T, s1: List[T] -> Bool -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p))","not p(List.cons(s0(p), s1(p)))"]}
{"goal":"get_idx_out_of_bounds","proof":["not idx >= list.length or not p(list) or list.get_idx(idx) = Option.none[T]"]}
{"goal":"exists(k0: T, k1: List[T]) { lb = List.cons(k0, k1) }","proof":["let (s0: List[T] -> T, s1: List[T] -> List[T]) satisfy { forall(x0: List[T]) { List.cons(s0(x0), s1(x0)) = x0 or List.nil[T] = x0 } }","List.cons(s0(lb), s1(lb)) != lb","List.cons(s0(lb), s1(lb)) = lb or List.nil[T] = lb"]}
{"goal":"List.nil[T].get_idx(0) = Option.none[T]","proof":["List.nil[T] != List.nil[T] or List.nil[T].get_idx(0) = Option.none[T]"]}
{"goal":"lb.get_idx(0) = Option.some(hb)","proof":["List.cons(hb, tb) != lb or 0 > 0 or lb.get_idx(0) = Option.some(hb)","0 > 0 = 0 < 0","not 0 < 0","List.cons(hb, tb) != lb or 0 > 0","0 > 0"]}
{"goal":"List.nil[T].get_idx(0) != lb.get_idx(0)","proof":["List.nil[T].get_idx(0) = Option.some(hb)","Option.some(hb) = Option.none[T]","Option.some(hb) != Option.none[T]"]}
{"goal":"lb.length >= 1","proof":["not lb.length < 0.suc or lb.length < 0 or lb.length = 0","1 <= lb.length = lb.length >= 1","not 1 <= lb.length","1 <= lb.length or lb.length < 1","lb.length != 0 or List.nil[T] = lb","not lb.length < 0","lb.length != 0","lb.length < 1","not lb.length < 0.suc","lb.length < 0.suc"]}
{"goal":"n >= 1","proof":["not 1 <= lb.length or not lb.length <= n or 1 <= n","1 <= lb.length = lb.length >= 1","1 <= n = n >= 1","not 1 <= n","1 <= lb.length","not 1 <= lb.length or 1 <= n"]}
{"goal":"differ[T](List.nil[T], lb, n)","proof":["not 0 < n or differ[T](List.nil[T], lb, n) or List.nil[T].get_idx(0) = lb.get_idx(0)","lb.get_idx(0) != Option.none[T]","not 0 <= n or 0 < n or n = 0","not n >= lb.length or lb.get_idx(n) = Option.none[T]","lb.length <= n = n >= lb.length","n >= lb.length","List.nil[T] != List.nil[T] or List.nil[T].length = 0","List.nil[T].length = 0","0 <= n","not 0 < n or List.nil[T].get_idx(0) = lb.get_idx(0)","not 0 < n","n = 0","lb.get_idx(n) = Option.none[T]","lb.get_idx(n) != Option.none[T]"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> List[T] satisfy { forall(x0: List[T], x1: List[T]) { not x0.length <= n or not x1.length <= n or not p(x0) or differ[T](x0, x1, n) or x0 = x1 } and forall(x2: List[T]) { s0(x2) != x2 or p(x2) } and forall(x3: List[T]) { x3.length <= n or p(x3) } and forall(x4: List[T]) { s0(x4).length <= n or p(x4) } and forall(x5: List[T]) { not differ[T](x5, s0(x5), n) or p(x5) } }","s0(List.nil[T]) != List.nil[T] or p(List.nil[T])","List.nil[T].length <= n or p(List.nil[T])","not differ[T](List.nil[T], s0(List.nil[T]), n) or p(List.nil[T])","s0(List.nil[T]).length <= n or p(List.nil[T])","not List.nil[T].length <= n or not s0(List.nil[T]).length <= n or differ[T](List.nil[T], s0(List.nil[T]), n) or s0(List.nil[T]) = List.nil[T]","s0(List.nil[T]) != List.nil[T]","List.nil[T].length <= n","s0(List.nil[T]).length <= n","not differ[T](List.nil[T], s0(List.nil[T]), n)","differ[T](List.nil[T], s0(List.nil[T]), n)"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":["List.cons(ha, ta) != List.cons(ha, ta) or 0 > 0 or List.cons(ha, ta).get_idx(0) = Option.some(ha)","0 > 0 = 0 < 0","not 0 < 0","List.cons(ha, ta) != List.cons(ha, ta) or 0 > 0","0 > 0"]}
{"goal":"List.nil[T].get_idx(0) = Option.none[T]","proof":["lb.get_idx(0) != Option.none[T]","List.nil[T] != lb or lb.get_idx(0) = Option.none[T]"]}
{"goal":"List.cons(ha, ta).get_idx(0) != lb.get_idx(0)","proof":["lb.get_idx(0) = Option.some(ha)","List.nil[T].get_idx(0) = Option.some(ha)","Option.some(ha) = Option.none[T]","Option.some(ha) != Option.none[T]"]}
{"goal":"List.cons(ha, ta).length >= 1","proof":["List.cons(ha, ta) != List.cons(ha, ta) or List.cons(ha, ta).length = ta.length.suc","1 + ta.length != 1 + ta.length or 1 <= 1 + ta.length","1 <= ta.length.suc = ta.length.suc >= 1","1 + ta.length = ta.length.suc","1 <= 1 + ta.length","List.cons(ha, ta).length = ta.length.suc","not ta.length.suc >= 1","not 1 <= ta.length.suc"]}
{"goal":"n >= 1","proof":["not 1 <= List.cons(ha, ta).length or not List.cons(ha, ta).length <= n or 1 <= n","1 <= List.cons(ha, ta).length = List.cons(ha, ta).length >= 1","1 <= n = n >= 1","not 1 <= n","1 <= List.cons(ha, ta).length","not 1 <= List.cons(ha, ta).length or 1 <= n"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not 0 < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)","not n >= List.cons(ha, ta).length or List.cons(ha, ta).get_idx(n) = Option.none[T]","n < 0 or 0 < n or n = 0","List.nil[T] != lb or lb.get_idx(0) = Option.none[T]","List.cons(ha, ta).length <= n = n >= List.cons(ha, ta).length","n >= List.cons(ha, ta).length","not n < 0","lb.get_idx(0) = Option.none[T]","not 0 < n or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)","not 0 < n","List.cons(ha, ta).get_idx(0) != Option.none[T]","List.cons(ha, ta).get_idx(n) = Option.none[T]","n = 0"]}
{"goal":"exists(k0: T, k1: List[T]) { lb = List.cons(k0, k1) }","proof":["let (s0: List[T] -> T, s1: List[T] -> List[T]) satisfy { forall(x0: List[T]) { List.cons(s0(x0), s1(x0)) = x0 or List.nil[T] = x0 } }","List.cons(s0(lb), s1(lb)) != lb","List.cons(s0(lb), s1(lb)) = lb or List.nil[T] = lb"]}
{"goal":"List.cons(ha, ta).length >= 1","proof":["List.cons(ha, ta) != List.cons(ha, ta) or List.cons(ha, ta).length = ta.length.suc","1 + ta.length != 1 + ta.length or 1 <= 1 + ta.length","1 <= ta.length.suc = ta.length.suc >= 1","1 + ta.length = ta.length.suc","1 <= 1 + ta.length","List.cons(ha, ta).length = ta.length.suc","not ta.length.suc >= 1","not 1 <= ta.length.suc"]}
{"goal":"n >= 1","proof":["not 1 <= List.cons(ha, ta).length or not List.cons(ha, ta).length <= n or 1 <= n","1 <= List.cons(ha, ta).length = List.cons(ha, ta).length >= 1","1 <= n = n >= 1","not 1 <= n","1 <= List.cons(ha, ta).length","not 1 <= List.cons(ha, ta).length or 1 <= n"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":["List.cons(ha, ta) != List.cons(ha, ta) or 0 > 0 or List.cons(ha, ta).get_idx(0) = Option.some(ha)","0 > 0 = 0 < 0","not 0 < 0","List.cons(ha, ta) != List.cons(ha, ta) or 0 > 0","0 > 0"]}
{"goal":"List.cons(hb, tb).get_idx(0) = Option.some(hb)","proof":["lb.get_idx(0) != Option.some(hb)","List.cons(hb, tb) != lb or 0 > 0 or lb.get_idx(0) = Option.some(hb)","0 > 0 = 0 < 0","not 0 < 0","List.cons(hb, tb) != lb or 0 > 0","0 > 0"]}
{"goal":"List.cons(ha, ta) = List.cons(hb, tb)","proof":[]}
{"goal":"false","proof":[]}
{"goal":"List.cons(ha, ta).length = ta.length.suc","proof":["List.cons(ha, ta) != List.cons(ha, ta) or List.cons(ha, ta).length = ta.length.suc","List.cons(ha, ta) != List.cons(ha, ta)"]}
{"goal":"ta.length.suc <= n","proof":[]}
{"goal":"ta.length < n","proof":["not ta.length.suc <= n or not ta.length < ta.length.suc or ta.length < n","ta.length < ta.length.suc","not ta.length < ta.length.suc or not ta.length.suc <= n"]}
{"goal":"List.cons(hb, tb).length = tb.length.suc","proof":["tb.length.suc != lb.length","List.cons(ha, tb) = lb","List.cons(ha, tb) != lb or tb.length.suc = lb.length"]}
{"goal":"tb.length < n","proof":["not tb.length.suc <= n or not tb.length < tb.length.suc or tb.length < n","tb.length < tb.length.suc","not tb.length < tb.length.suc or not tb.length.suc <= n","not tb.length.suc <= n"]}
{"goal":"p(ta)","proof":[]}
{"goal":"differ[T](ta, tb, n)","proof":["not ta.length <= n or not tb.length <= n or not p(ta) or differ[T](ta, tb, n) or tb = ta","not ta.length < n or ta.length <= n","not tb.length < n or tb.length <= n","not tb.length <= n or not ta.length <= n","tb.length <= n","ta.length <= n","not ta.length <= n"]}
{"goal":"exists(k0: Nat) { k0 < n and ta.get_idx(k0) != tb.get_idx(k0) }","proof":["let s0: (List[T], List[T], Nat) -> Nat satisfy { forall(x0: List[T], x1: List[T], x2: Nat) { not differ[T](x0, x1, x2) or s0(x0, x1, x2) < x2 } and forall(x3: List[T], x4: List[T], x5: Nat) { x3.get_idx(s0(x3, x4, x5)) != x4.get_idx(s0(x3, x4, x5)) or not differ[T](x3, x4, x5) } and forall(x6: Nat, x7: Nat, x8: List[T], x9: List[T]) { not x6 < x7 or differ[T](x8, x9, x7) or x8.get_idx(x6) = x9.get_idx(x6) } }","not s0(ta, tb, n) < n or tb.get_idx(s0(ta, tb, n)) = ta.get_idx(s0(ta, tb, n))","tb.get_idx(s0(ta, tb, n)) != ta.get_idx(s0(ta, tb, n)) or not differ[T](ta, tb, n)","not differ[T](ta, tb, n) or s0(ta, tb, n) < n","s0(ta, tb, n) < n","tb.get_idx(s0(ta, tb, n)) != ta.get_idx(s0(ta, tb, n))","tb.get_idx(s0(ta, tb, n)) = ta.get_idx(s0(ta, tb, n))"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["i.suc != n","not i < n or i.suc < n or i.suc = n","i.suc < n","not i.suc ∈ n.range or not i.suc >= n","not i.suc < n or i.suc ∈ n.range","not i.suc ∈ n.range","i.suc ∈ n.range"]}
{"goal":"i = ip","proof":["not i < n or i.suc < n or i.suc = n","n <= i.suc = i.suc >= n","not n <= i.suc or not i.suc < n","ip.suc != i.suc or ip = i","ip.suc != i.suc","i.suc != n","i.suc < n","n <= i.suc","not n <= i.suc"]}
{"goal":"ta.length.suc <= ip.suc","proof":["not ta.length.suc <= n"]}
{"goal":"ta.length <= ip","proof":["not ta.length.suc <= ip.suc or ta.length <= ip"]}
{"goal":"tb.length.suc <= ip.suc","proof":[]}
{"goal":"tb.length <= ip","proof":["not tb.length.suc <= ip.suc or tb.length <= ip"]}
{"goal":"ta.get_idx(ip) = Option.none[T]","proof":["ta.length <= i","not ip >= ta.length or ta.get_idx(ip) = Option.none[T]","not ip >= ta.length","not i >= ta.length","ta.length <= i = i >= ta.length"]}
{"goal":"tb.get_idx(ip) = Option.none[T]","proof":["tb.length <= i","not ip >= tb.length or tb.get_idx(ip) = Option.none[T]","not ip >= tb.length","not i >= tb.length","tb.length <= i = i >= tb.length"]}
{"goal":"false","proof":[]}
{"goal":"i.suc < n","proof":["not i < n or i.suc < n or i.suc = n","i.suc = n","not n >= n","not n < n","n <= n = n >= n","n <= n or n < n","not n <= n","n <= n"]}
{"goal":"i + 1 = i.suc","proof":["i + 1 = 1 + i","1 + i != i.suc","1 + i = i.suc"]}
{"goal":"i + 1 > 0","proof":["i + 1 > 0 = 0 < i + 1","not 0 < i + 1","not 0 < i.suc","0 < 0 + i.suc","0 + i.suc = i.suc"]}
{"goal":"i.suc > 0","proof":[]}
{"goal":"List.cons(ha, ta).get_idx(i + 1) = ta.get_idx(i)","proof":["not i + 1 > 0 or List.cons(ha, ta) != List.cons(ha, ta) or List.cons(ha, ta).get_idx(i + 1) = ta.get_idx(i + 1 - 1)","i + 1 - 1 = i","not i + 1 > 0 or List.cons(ha, ta).get_idx(i + 1) = ta.get_idx(i + 1 - 1)","List.cons(ha, ta).get_idx(i + 1) != ta.get_idx(i + 1 - 1)"]}
{"goal":"List.cons(ha, ta).get_idx(i.suc) = ta.get_idx(i)","proof":["List.cons(ha, ta).get_idx(i + 1) != ta.get_idx(i)"]}
{"goal":"List.cons(hb, tb).get_idx(i + 1) = tb.get_idx(i)","proof":["not i + 1 > 0 or List.cons(hb, tb) != List.cons(hb, tb) or List.cons(hb, tb).get_idx(i + 1) = tb.get_idx(i + 1 - 1)","i + 1 - 1 = i","not i + 1 > 0 or List.cons(hb, tb).get_idx(i + 1) = tb.get_idx(i + 1 - 1)","List.cons(hb, tb).get_idx(i + 1) != tb.get_idx(i + 1 - 1)"]}
{"goal":"List.cons(hb, tb).get_idx(i.suc) = tb.get_idx(i)","proof":["List.cons(hb, tb).get_idx(i + 1) != tb.get_idx(i)"]}
{"goal":"ta.get_idx(i) != tb.get_idx(i)","proof":[]}
{"goal":"List.cons(ha, ta).get_idx(i.suc) != List.cons(hb, tb).get_idx(i.suc)","proof":[]}
{"goal":"List.cons(hb, tb) = lb","proof":[]}
{"goal":"List.cons(ha, ta).get_idx(i.suc) != lb.get_idx(i.suc)","proof":["List.cons(hb, tb).get_idx(i.suc) = List.cons(ha, ta).get_idx(i.suc)"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not i.suc < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(i.suc) = lb.get_idx(i.suc)","not i.suc < n or List.cons(ha, ta).get_idx(i.suc) = lb.get_idx(i.suc)"]}
{"goal":"ha != hb","proof":[]}
{"goal":"List.cons(ha, ta).get_idx(0) != List.cons(hb, tb).get_idx(0)","proof":["List.cons(ha, ta).get_idx(0) = Option.some(hb)","Option.some(hb) = Option.some(ha)","Option.some(hb) != Option.some(ha) or hb = ha"]}
{"goal":"List.cons(hb, tb) = lb","proof":[]}
{"goal":"List.cons(ha, ta).get_idx(0) != lb.get_idx(0)","proof":["List.cons(hb, tb).get_idx(0) = List.cons(ha, ta).get_idx(0)"]}
{"goal":"0 < n","proof":["not 0.suc <= n or not 0 < 0.suc or 0 < n","1 <= n = n >= 1","not 0.suc <= n or not 0 < 0.suc","0 + 1 = 0.suc","0 + 1 = 1","0 < 0.suc","not 0.suc <= n"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not 0 < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)","not 0 < n or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":[]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":[]}
{"goal":"p(List.cons(ha, ta))","proof":["let s0: List[T] -> List[T] satisfy { forall(x0: List[T], x1: List[T]) { not x0.length <= n or not x1.length <= n or not p(x0) or differ[T](x0, x1, n) or x0 = x1 } and forall(x2: List[T]) { s0(x2) != x2 or p(x2) } and forall(x3: List[T]) { x3.length <= n or p(x3) } and forall(x4: List[T]) { s0(x4).length <= n or p(x4) } and forall(x5: List[T]) { not differ[T](x5, s0(x5), n) or p(x5) } }","s0(List.cons(ha, ta)) != List.cons(ha, ta) or p(List.cons(ha, ta))","List.cons(ha, ta).length <= n or p(List.cons(ha, ta))","not differ[T](List.cons(ha, ta), s0(List.cons(ha, ta)), n) or p(List.cons(ha, ta))","s0(List.cons(ha, ta)).length <= n or p(List.cons(ha, ta))","not List.cons(ha, ta).length <= n or not s0(List.cons(ha, ta)).length <= n or differ[T](List.cons(ha, ta), s0(List.cons(ha, ta)), n) or s0(List.cons(ha, ta)) = List.cons(ha, ta)","List.cons(ha, ta).length <= n","s0(List.cons(ha, ta)).length <= n","s0(List.cons(ha, ta)) != List.cons(ha, ta)","not differ[T](List.cons(ha, ta), s0(List.cons(ha, ta)), n)","differ[T](List.cons(ha, ta), s0(List.cons(ha, ta)), n)"]}
{"goal":"p(a)","proof":["let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(a)","p(s1) or p(a)","p(s1)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(a)","not p(List.cons(s0, s1)) or p(a)","not p(s1) or p(List.cons(s0, s1))","not p(List.cons(s0, s1))"]}
{"goal":"differ[T](a, b, n)","proof":["not a.length <= n or not b.length <= n or not p(a) or differ[T](a, b, n) or b = a"]}
{"goal":"lists_differ_at_index","proof":["not a.length <= n"]}
