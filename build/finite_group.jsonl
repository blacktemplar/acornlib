{"goal":"subgroup_of_finite_group_is_finite","proof":["let (s0: G -> Bool -> List[G], s1: (G -> Bool, List[G]) -> G) satisfy { forall(x0: G -> Bool, x1: G) { not finite_constraint[G](x0) or not x0(x1) or s0(x0).contains(x1) } and forall(x2: G -> Bool, x3: List[G]) { finite_constraint[G](x2) or x2(s1(x2, x3)) } and forall(x4: List[G], x5: G -> Bool) { not x4.contains(s1(x5, x4)) or finite_constraint[G](x5) } }","not G.elements.contains(s1(s.contains, G.elements)) or finite_constraint[G](s.contains)","not G.elements.contains(s1(s.contains, G.elements))","not G.elements.contains_every or G.elements.contains(s1(s.contains, G.elements))","not G.elements.contains_every"]}
{"goal":"x = G.1","proof":["List.cons(G.1, List.nil[G]) != s or not s.contains(x) or List.nil[G].contains(x) or G.1 = x","List.cons(G.1, List.nil[G]) = List.singleton(G.1)","List.nil[G] != List.nil[G] or not List.nil[G].contains(x)","not List.nil[G].contains(x)","List.cons(G.1, List.nil[G]) = s","List.cons(G.1, List.nil[G]) != s or not s.contains(x) or List.nil[G].contains(x)"]}
{"goal":"identity_subgroup[G].contains(x)","proof":["not subgroup_constraint[G](lib(subgroup).is_identity[G]) or x ∈ Subgroup.new[G](lib(subgroup).is_identity[G]) = lib(subgroup).is_identity(x)","G.1 != x or lib(subgroup).is_identity(x)","lib(subgroup).is_identity(x)","not x ∈ Subgroup.new[G](lib(subgroup).is_identity[G])","not subgroup_constraint[G](lib(subgroup).is_identity[G]) or not lib(subgroup).is_identity(x) or x ∈ Subgroup.new[G](lib(subgroup).is_identity[G])"]}
{"goal":"not identity_subgroup[G].contains(x)","proof":["List.cons(x, List.nil[G]) != s or x != x or s.contains(x)","not identity_subgroup[G].contains(x) or G.1 = x","G.1 = x","List.cons(G.1, List.nil[G]) = List.singleton(G.1)","List.cons(G.1, List.nil[G]) = s","List.cons(x, List.nil[G]) = s","List.cons(x, List.nil[G]) != s or s.contains(x)"]}
{"goal":"s.contains(x) = identity_subgroup[G].contains(x)","proof":["not identity_subgroup[G].contains(x)","s.contains(x)"]}
{"goal":"s.contains = identity_subgroup[G].contains","proof":["let s0: G satisfy { identity_subgroup[G].contains(s0) != s.contains(s0) }","identity_subgroup[G].contains(s0) = s.contains(s0)"]}
{"goal":"subgroup_constraint[G](s.contains)","proof":["not subgroup_constraint[G](identity_subgroup[G].contains)","subgroup_constraint[G](identity_subgroup[G].contains)"]}
{"goal":"exists(k0: List[G]) { k0.is_unique and subgroup_constraint[G](k0.contains) }","proof":["not subgroup_constraint[G](s.contains) or not s.is_unique","not s.is_unique","List.singleton(G.1).is_unique"]}
{"goal":"s.elements.contains(x) implies G.elements.contains(x)","proof":["not G.elements.contains_every or G.elements.contains(x)","not G.elements.contains_every"]}
{"goal":"s.elements.unique.length <= G.elements.length","proof":["let s0: (List[G], List[G]) -> G satisfy { forall(x0: List[G], x1: List[G]) { x0.unique.length <= x1.length or x0.contains(s0(x0, x1)) } and forall(x2: List[G], x3: List[G]) { not x2.contains(s0(x3, x2)) or x3.unique.length <= x2.length } }","not s.elements.contains(s0(s.elements, G.elements)) or G.elements.contains(s0(s.elements, G.elements))","not G.elements.contains(s0(s.elements, G.elements)) or s.elements.unique.length <= G.elements.length","s.elements.unique.length <= G.elements.length or s.elements.contains(s0(s.elements, G.elements))","not G.elements.contains(s0(s.elements, G.elements))","s.elements.contains(s0(s.elements, G.elements))","not s.elements.contains(s0(s.elements, G.elements))"]}
{"goal":"s.elements.is_unique","proof":["s.elements.is_unique"]}
{"goal":"subgroup_has_order_at_most_G_order","proof":["s.elements.length = s.order","not s.elements.length <= G.order","not s.elements.is_unique or s.elements.unique = s.elements","s.elements.unique.length <= G.order","s.elements.unique = s.elements"]}
{"goal":"cyclic_subgroup.length = n","proof":["map[Nat, G](n.range, f).length = n.range.length","map[Nat, G](n.range, f).length != n","n.range.length != n","n.range.length = n"]}
{"goal":"cyclic_subgroup.unique.length <= G.elements.length","proof":["let s0: (List[G], List[G]) -> G satisfy { forall(x0: List[G], x1: List[G]) { x0.unique.length <= x1.length or x0.contains(s0(x0, x1)) } and forall(x2: List[G], x3: List[G]) { not x2.contains(s0(x3, x2)) or x3.unique.length <= x2.length } }","not G.elements.contains(s0(cyclic_subgroup, G.elements)) or cyclic_subgroup.unique.length <= G.elements.length","not G.elements.contains(s0(cyclic_subgroup, G.elements))","not G.elements.contains_every or G.elements.contains(s0(cyclic_subgroup, G.elements))","not G.elements.contains_every"]}
{"goal":"map[Nat, G](n.range, f).unique.length <= G.elements.length","proof":["not cyclic_subgroup.unique.length <= G.elements.length"]}
{"goal":"cyclic_subgroup.unique.length < cyclic_subgroup.length","proof":["not cyclic_subgroup.unique.length < n","not G.elements.length < G.elements.length.suc or not cyclic_subgroup.unique.length <= G.elements.length or cyclic_subgroup.unique.length < G.elements.length.suc","G.order + 1 = G.order.suc","G.elements.length < G.elements.length.suc","not cyclic_subgroup.unique.length < G.order + 1","not cyclic_subgroup.unique.length < G.order.suc","not G.elements.length < G.elements.length.suc or cyclic_subgroup.unique.length < G.elements.length.suc","not cyclic_subgroup.unique.length < G.elements.length.suc","cyclic_subgroup.unique.length < G.elements.length.suc"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < cyclic_subgroup.length and f(k0) = f(k1) }","proof":["let (s0: (Nat, Nat -> G) -> Nat, s1: (Nat, Nat -> G) -> Nat) satisfy { forall(x0: Nat, x1: Nat -> G) { not map[Nat, G](x0.range, x1).unique.length < x0 or s0(x0, x1) < s1(x0, x1) } and forall(x2: Nat, x3: Nat -> G) { not map[Nat, G](x2.range, x3).unique.length < x2 or s1(x2, x3) < x2 } and forall(x4: Nat, x5: Nat -> G) { not map[Nat, G](x4.range, x5).unique.length < x4 or x5(s1(x4, x5)) = x5(s0(x4, x5)) } }","not s1(n, f) < cyclic_subgroup.length or not s0(n, f) < s1(n, f) or f(s1(n, f)) != f(s0(n, f))","not map[Nat, G](n.range, f).unique.length < n or f(s1(n, f)) = f(s0(n, f))","not map[Nat, G](n.range, f).unique.length < n or s0(n, f) < s1(n, f)","not map[Nat, G](n.range, f).unique.length < n or s1(n, f) < n","map[Nat, G](n.range, f).unique.length < cyclic_subgroup.length","map[Nat, G](n.range, f).unique.length < n","s1(n, f) < n","s0(n, f) < s1(n, f)","f(s1(n, f)) = f(s0(n, f))","s1(n, f) < cyclic_subgroup.length","not s1(n, f) < cyclic_subgroup.length"]}
{"goal":"j < n","proof":["not j < cyclic_subgroup.length"]}
{"goal":"i < n","proof":["not i < j or not j <= n or i < n","not j < n or j <= n","not i < j or not j <= n","j <= n","not j <= n"]}
{"goal":"g.pow(i) = g.pow(j)","proof":["g.pow(i) = f(i)","g.pow(j) = f(j)"]}
{"goal":"g.pow(j - i) = G.1","proof":["g.pow(j) != g.pow(i) or not j > i or g.pow(j - i) = G.1","not j > i","j > i = i < j"]}
{"goal":"j > i","proof":["j > i = i < j"]}
{"goal":"i + m = j","proof":["not i <= j or j - i + i = j","not i < j or i <= j","m + i = i + m","m + i != j","i <= j","j - i + i != j","j - i + i = j"]}
{"goal":"m > 0","proof":["0 < m or m < 0 or m = 0","m + i = i + m","m > 0 = 0 < m","not 0 < m","not i < j or j != i","j != i","0 + i = i","m < 0 or m = 0","not m < 0","m = 0"]}
{"goal":"m + i < n","proof":["n > j = j < n","n > m + i = m + i < n","m + i = i + m"]}
{"goal":"m < n","proof":["not j < n or not m <= j or m < n","m + i != j or m <= j","m + i = i + m","not m <= j or not j < n","not m <= j","m + i = j"]}
{"goal":"m <= G.order","proof":["not m.suc <= G.order.suc or m <= G.order","not m.suc <= G.order.suc","not m < n or m.suc <= n","G.order + 1 = 1 + G.order","1 + G.order = G.order.suc","m.suc <= n"]}
{"goal":"g.pow(m) = G.1","proof":["g.pow(j - i) != G.1"]}
{"goal":"all_elements_have_order_at_most_G","proof":["g.pow(m) != G.1 or not m <= G.order or not m > 0","g.pow(m) != G.1"]}
{"goal":"all_elements_have_finite_order","proof":["let s0: G -> Nat satisfy { forall(x0: G) { s0(x0) > 0 } and forall(x1: G) { s0(x1) <= G.order } and forall(x2: G) { x2.pow(s0(x2)) = G.1 } }","g.pow(s0(g)) != G.1 or s0(g) = 0 or has_finite_order(g)","s0(g) > 0 = 0 < s0(g)","g.pow(s0(g)) != G.1 or s0(g) = 0","g.pow(s0(g)) = G.1","s0(g) = 0","not 0 < s0(g) or s0(g) != 0","s0(g) > 0","not 0 < s0(g)"]}
